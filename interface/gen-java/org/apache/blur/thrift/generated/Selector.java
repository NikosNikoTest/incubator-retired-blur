/**
 * Autogenerated by Thrift Compiler (0.7.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package org.apache.blur.thrift.generated;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Select carries the request for information to be retrieved from the stored columns.
 */
public class Selector implements org.apache.thrift.TBase<Selector, Selector._Fields>, java.io.Serializable, Cloneable {
  private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("Selector");

  private static final org.apache.thrift.protocol.TField RECORD_ONLY_FIELD_DESC = new org.apache.thrift.protocol.TField("recordOnly", org.apache.thrift.protocol.TType.BOOL, (short)1);
  private static final org.apache.thrift.protocol.TField LOCATION_ID_FIELD_DESC = new org.apache.thrift.protocol.TField("locationId", org.apache.thrift.protocol.TType.STRING, (short)2);
  private static final org.apache.thrift.protocol.TField ROW_ID_FIELD_DESC = new org.apache.thrift.protocol.TField("rowId", org.apache.thrift.protocol.TType.STRING, (short)3);
  private static final org.apache.thrift.protocol.TField RECORD_ID_FIELD_DESC = new org.apache.thrift.protocol.TField("recordId", org.apache.thrift.protocol.TType.STRING, (short)4);
  private static final org.apache.thrift.protocol.TField COLUMN_FAMILIES_TO_FETCH_FIELD_DESC = new org.apache.thrift.protocol.TField("columnFamiliesToFetch", org.apache.thrift.protocol.TType.SET, (short)5);
  private static final org.apache.thrift.protocol.TField COLUMNS_TO_FETCH_FIELD_DESC = new org.apache.thrift.protocol.TField("columnsToFetch", org.apache.thrift.protocol.TType.MAP, (short)6);
  private static final org.apache.thrift.protocol.TField ALLOW_STALE_DATA_FIELD_DESC = new org.apache.thrift.protocol.TField("allowStaleData", org.apache.thrift.protocol.TType.BOOL, (short)7);

  /**
   * Fetch the Record only, not the entire Row.
   */
  public boolean recordOnly; // required
  /**
   * The location id of the Record or Row to be fetched.
   */
  public String locationId; // required
  /**
   * The row id of the Row to be fetched, not to be used with location id.
   */
  public String rowId; // required
  /**
   * The record id of the Record to be fetched, not to be used with location id.  However the row id needs to be provided to locate the correct Row with the requested Record.
   */
  public String recordId; // required
  /**
   * The column families to fetch.  If null, fetch all.  If empty, fetch none.
   */
  public Set<String> columnFamiliesToFetch; // required
  /**
   * The columns in the families to fetch.  If null, fetch all.  If empty, fetch none.
   */
  public Map<String,Set<String>> columnsToFetch; // required
  /**
   * @deprecated This value is no longer used.  This allows the fetch to see the most current data that has been added to the table.
   */
  public boolean allowStaleData; // required

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements org.apache.thrift.TFieldIdEnum {
    /**
     * Fetch the Record only, not the entire Row.
     */
    RECORD_ONLY((short)1, "recordOnly"),
    /**
     * The location id of the Record or Row to be fetched.
     */
    LOCATION_ID((short)2, "locationId"),
    /**
     * The row id of the Row to be fetched, not to be used with location id.
     */
    ROW_ID((short)3, "rowId"),
    /**
     * The record id of the Record to be fetched, not to be used with location id.  However the row id needs to be provided to locate the correct Row with the requested Record.
     */
    RECORD_ID((short)4, "recordId"),
    /**
     * The column families to fetch.  If null, fetch all.  If empty, fetch none.
     */
    COLUMN_FAMILIES_TO_FETCH((short)5, "columnFamiliesToFetch"),
    /**
     * The columns in the families to fetch.  If null, fetch all.  If empty, fetch none.
     */
    COLUMNS_TO_FETCH((short)6, "columnsToFetch"),
    /**
     * @deprecated This value is no longer used.  This allows the fetch to see the most current data that has been added to the table.
     */
    ALLOW_STALE_DATA((short)7, "allowStaleData");

    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 1: // RECORD_ONLY
          return RECORD_ONLY;
        case 2: // LOCATION_ID
          return LOCATION_ID;
        case 3: // ROW_ID
          return ROW_ID;
        case 4: // RECORD_ID
          return RECORD_ID;
        case 5: // COLUMN_FAMILIES_TO_FETCH
          return COLUMN_FAMILIES_TO_FETCH;
        case 6: // COLUMNS_TO_FETCH
          return COLUMNS_TO_FETCH;
        case 7: // ALLOW_STALE_DATA
          return ALLOW_STALE_DATA;
        default:
          return null;
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }

    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }

    private final short _thriftId;
    private final String _fieldName;

    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }

    public short getThriftFieldId() {
      return _thriftId;
    }

    public String getFieldName() {
      return _fieldName;
    }
  }

  // isset id assignments
  private static final int __RECORDONLY_ISSET_ID = 0;
  private static final int __ALLOWSTALEDATA_ISSET_ID = 1;
  private BitSet __isset_bit_vector = new BitSet(2);

  public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
  static {
    Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.RECORD_ONLY, new org.apache.thrift.meta_data.FieldMetaData("recordOnly", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
    tmpMap.put(_Fields.LOCATION_ID, new org.apache.thrift.meta_data.FieldMetaData("locationId", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
    tmpMap.put(_Fields.ROW_ID, new org.apache.thrift.meta_data.FieldMetaData("rowId", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
    tmpMap.put(_Fields.RECORD_ID, new org.apache.thrift.meta_data.FieldMetaData("recordId", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
    tmpMap.put(_Fields.COLUMN_FAMILIES_TO_FETCH, new org.apache.thrift.meta_data.FieldMetaData("columnFamiliesToFetch", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.SetMetaData(org.apache.thrift.protocol.TType.SET, 
            new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING))));
    tmpMap.put(_Fields.COLUMNS_TO_FETCH, new org.apache.thrift.meta_data.FieldMetaData("columnsToFetch", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.MapMetaData(org.apache.thrift.protocol.TType.MAP, 
            new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING), 
            new org.apache.thrift.meta_data.SetMetaData(org.apache.thrift.protocol.TType.SET, 
                new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)))));
    tmpMap.put(_Fields.ALLOW_STALE_DATA, new org.apache.thrift.meta_data.FieldMetaData("allowStaleData", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(Selector.class, metaDataMap);
  }

  public Selector() {
  }

  public Selector(
    boolean recordOnly,
    String locationId,
    String rowId,
    String recordId,
    Set<String> columnFamiliesToFetch,
    Map<String,Set<String>> columnsToFetch,
    boolean allowStaleData)
  {
    this();
    this.recordOnly = recordOnly;
    setRecordOnlyIsSet(true);
    this.locationId = locationId;
    this.rowId = rowId;
    this.recordId = recordId;
    this.columnFamiliesToFetch = columnFamiliesToFetch;
    this.columnsToFetch = columnsToFetch;
    this.allowStaleData = allowStaleData;
    setAllowStaleDataIsSet(true);
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public Selector(Selector other) {
    __isset_bit_vector.clear();
    __isset_bit_vector.or(other.__isset_bit_vector);
    this.recordOnly = other.recordOnly;
    if (other.isSetLocationId()) {
      this.locationId = other.locationId;
    }
    if (other.isSetRowId()) {
      this.rowId = other.rowId;
    }
    if (other.isSetRecordId()) {
      this.recordId = other.recordId;
    }
    if (other.isSetColumnFamiliesToFetch()) {
      Set<String> __this__columnFamiliesToFetch = new HashSet<String>();
      for (String other_element : other.columnFamiliesToFetch) {
        __this__columnFamiliesToFetch.add(other_element);
      }
      this.columnFamiliesToFetch = __this__columnFamiliesToFetch;
    }
    if (other.isSetColumnsToFetch()) {
      Map<String,Set<String>> __this__columnsToFetch = new HashMap<String,Set<String>>();
      for (Map.Entry<String, Set<String>> other_element : other.columnsToFetch.entrySet()) {

        String other_element_key = other_element.getKey();
        Set<String> other_element_value = other_element.getValue();

        String __this__columnsToFetch_copy_key = other_element_key;

        Set<String> __this__columnsToFetch_copy_value = new HashSet<String>();
        for (String other_element_value_element : other_element_value) {
          __this__columnsToFetch_copy_value.add(other_element_value_element);
        }

        __this__columnsToFetch.put(__this__columnsToFetch_copy_key, __this__columnsToFetch_copy_value);
      }
      this.columnsToFetch = __this__columnsToFetch;
    }
    this.allowStaleData = other.allowStaleData;
  }

  public Selector deepCopy() {
    return new Selector(this);
  }

  @Override
  public void clear() {
    setRecordOnlyIsSet(false);
    this.recordOnly = false;
    this.locationId = null;
    this.rowId = null;
    this.recordId = null;
    this.columnFamiliesToFetch = null;
    this.columnsToFetch = null;
    setAllowStaleDataIsSet(false);
    this.allowStaleData = false;
  }

  /**
   * Fetch the Record only, not the entire Row.
   */
  public boolean isRecordOnly() {
    return this.recordOnly;
  }

  /**
   * Fetch the Record only, not the entire Row.
   */
  public Selector setRecordOnly(boolean recordOnly) {
    this.recordOnly = recordOnly;
    setRecordOnlyIsSet(true);
    return this;
  }

  public void unsetRecordOnly() {
    __isset_bit_vector.clear(__RECORDONLY_ISSET_ID);
  }

  /** Returns true if field recordOnly is set (has been assigned a value) and false otherwise */
  public boolean isSetRecordOnly() {
    return __isset_bit_vector.get(__RECORDONLY_ISSET_ID);
  }

  public void setRecordOnlyIsSet(boolean value) {
    __isset_bit_vector.set(__RECORDONLY_ISSET_ID, value);
  }

  /**
   * The location id of the Record or Row to be fetched.
   */
  public String getLocationId() {
    return this.locationId;
  }

  /**
   * The location id of the Record or Row to be fetched.
   */
  public Selector setLocationId(String locationId) {
    this.locationId = locationId;
    return this;
  }

  public void unsetLocationId() {
    this.locationId = null;
  }

  /** Returns true if field locationId is set (has been assigned a value) and false otherwise */
  public boolean isSetLocationId() {
    return this.locationId != null;
  }

  public void setLocationIdIsSet(boolean value) {
    if (!value) {
      this.locationId = null;
    }
  }

  /**
   * The row id of the Row to be fetched, not to be used with location id.
   */
  public String getRowId() {
    return this.rowId;
  }

  /**
   * The row id of the Row to be fetched, not to be used with location id.
   */
  public Selector setRowId(String rowId) {
    this.rowId = rowId;
    return this;
  }

  public void unsetRowId() {
    this.rowId = null;
  }

  /** Returns true if field rowId is set (has been assigned a value) and false otherwise */
  public boolean isSetRowId() {
    return this.rowId != null;
  }

  public void setRowIdIsSet(boolean value) {
    if (!value) {
      this.rowId = null;
    }
  }

  /**
   * The record id of the Record to be fetched, not to be used with location id.  However the row id needs to be provided to locate the correct Row with the requested Record.
   */
  public String getRecordId() {
    return this.recordId;
  }

  /**
   * The record id of the Record to be fetched, not to be used with location id.  However the row id needs to be provided to locate the correct Row with the requested Record.
   */
  public Selector setRecordId(String recordId) {
    this.recordId = recordId;
    return this;
  }

  public void unsetRecordId() {
    this.recordId = null;
  }

  /** Returns true if field recordId is set (has been assigned a value) and false otherwise */
  public boolean isSetRecordId() {
    return this.recordId != null;
  }

  public void setRecordIdIsSet(boolean value) {
    if (!value) {
      this.recordId = null;
    }
  }

  public int getColumnFamiliesToFetchSize() {
    return (this.columnFamiliesToFetch == null) ? 0 : this.columnFamiliesToFetch.size();
  }

  public java.util.Iterator<String> getColumnFamiliesToFetchIterator() {
    return (this.columnFamiliesToFetch == null) ? null : this.columnFamiliesToFetch.iterator();
  }

  public void addToColumnFamiliesToFetch(String elem) {
    if (this.columnFamiliesToFetch == null) {
      this.columnFamiliesToFetch = new HashSet<String>();
    }
    this.columnFamiliesToFetch.add(elem);
  }

  /**
   * The column families to fetch.  If null, fetch all.  If empty, fetch none.
   */
  public Set<String> getColumnFamiliesToFetch() {
    return this.columnFamiliesToFetch;
  }

  /**
   * The column families to fetch.  If null, fetch all.  If empty, fetch none.
   */
  public Selector setColumnFamiliesToFetch(Set<String> columnFamiliesToFetch) {
    this.columnFamiliesToFetch = columnFamiliesToFetch;
    return this;
  }

  public void unsetColumnFamiliesToFetch() {
    this.columnFamiliesToFetch = null;
  }

  /** Returns true if field columnFamiliesToFetch is set (has been assigned a value) and false otherwise */
  public boolean isSetColumnFamiliesToFetch() {
    return this.columnFamiliesToFetch != null;
  }

  public void setColumnFamiliesToFetchIsSet(boolean value) {
    if (!value) {
      this.columnFamiliesToFetch = null;
    }
  }

  public int getColumnsToFetchSize() {
    return (this.columnsToFetch == null) ? 0 : this.columnsToFetch.size();
  }

  public void putToColumnsToFetch(String key, Set<String> val) {
    if (this.columnsToFetch == null) {
      this.columnsToFetch = new HashMap<String,Set<String>>();
    }
    this.columnsToFetch.put(key, val);
  }

  /**
   * The columns in the families to fetch.  If null, fetch all.  If empty, fetch none.
   */
  public Map<String,Set<String>> getColumnsToFetch() {
    return this.columnsToFetch;
  }

  /**
   * The columns in the families to fetch.  If null, fetch all.  If empty, fetch none.
   */
  public Selector setColumnsToFetch(Map<String,Set<String>> columnsToFetch) {
    this.columnsToFetch = columnsToFetch;
    return this;
  }

  public void unsetColumnsToFetch() {
    this.columnsToFetch = null;
  }

  /** Returns true if field columnsToFetch is set (has been assigned a value) and false otherwise */
  public boolean isSetColumnsToFetch() {
    return this.columnsToFetch != null;
  }

  public void setColumnsToFetchIsSet(boolean value) {
    if (!value) {
      this.columnsToFetch = null;
    }
  }

  /**
   * @deprecated This value is no longer used.  This allows the fetch to see the most current data that has been added to the table.
   */
  public boolean isAllowStaleData() {
    return this.allowStaleData;
  }

  /**
   * @deprecated This value is no longer used.  This allows the fetch to see the most current data that has been added to the table.
   */
  public Selector setAllowStaleData(boolean allowStaleData) {
    this.allowStaleData = allowStaleData;
    setAllowStaleDataIsSet(true);
    return this;
  }

  public void unsetAllowStaleData() {
    __isset_bit_vector.clear(__ALLOWSTALEDATA_ISSET_ID);
  }

  /** Returns true if field allowStaleData is set (has been assigned a value) and false otherwise */
  public boolean isSetAllowStaleData() {
    return __isset_bit_vector.get(__ALLOWSTALEDATA_ISSET_ID);
  }

  public void setAllowStaleDataIsSet(boolean value) {
    __isset_bit_vector.set(__ALLOWSTALEDATA_ISSET_ID, value);
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case RECORD_ONLY:
      if (value == null) {
        unsetRecordOnly();
      } else {
        setRecordOnly((Boolean)value);
      }
      break;

    case LOCATION_ID:
      if (value == null) {
        unsetLocationId();
      } else {
        setLocationId((String)value);
      }
      break;

    case ROW_ID:
      if (value == null) {
        unsetRowId();
      } else {
        setRowId((String)value);
      }
      break;

    case RECORD_ID:
      if (value == null) {
        unsetRecordId();
      } else {
        setRecordId((String)value);
      }
      break;

    case COLUMN_FAMILIES_TO_FETCH:
      if (value == null) {
        unsetColumnFamiliesToFetch();
      } else {
        setColumnFamiliesToFetch((Set<String>)value);
      }
      break;

    case COLUMNS_TO_FETCH:
      if (value == null) {
        unsetColumnsToFetch();
      } else {
        setColumnsToFetch((Map<String,Set<String>>)value);
      }
      break;

    case ALLOW_STALE_DATA:
      if (value == null) {
        unsetAllowStaleData();
      } else {
        setAllowStaleData((Boolean)value);
      }
      break;

    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case RECORD_ONLY:
      return Boolean.valueOf(isRecordOnly());

    case LOCATION_ID:
      return getLocationId();

    case ROW_ID:
      return getRowId();

    case RECORD_ID:
      return getRecordId();

    case COLUMN_FAMILIES_TO_FETCH:
      return getColumnFamiliesToFetch();

    case COLUMNS_TO_FETCH:
      return getColumnsToFetch();

    case ALLOW_STALE_DATA:
      return Boolean.valueOf(isAllowStaleData());

    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case RECORD_ONLY:
      return isSetRecordOnly();
    case LOCATION_ID:
      return isSetLocationId();
    case ROW_ID:
      return isSetRowId();
    case RECORD_ID:
      return isSetRecordId();
    case COLUMN_FAMILIES_TO_FETCH:
      return isSetColumnFamiliesToFetch();
    case COLUMNS_TO_FETCH:
      return isSetColumnsToFetch();
    case ALLOW_STALE_DATA:
      return isSetAllowStaleData();
    }
    throw new IllegalStateException();
  }

  @Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof Selector)
      return this.equals((Selector)that);
    return false;
  }

  public boolean equals(Selector that) {
    if (that == null)
      return false;

    boolean this_present_recordOnly = true;
    boolean that_present_recordOnly = true;
    if (this_present_recordOnly || that_present_recordOnly) {
      if (!(this_present_recordOnly && that_present_recordOnly))
        return false;
      if (this.recordOnly != that.recordOnly)
        return false;
    }

    boolean this_present_locationId = true && this.isSetLocationId();
    boolean that_present_locationId = true && that.isSetLocationId();
    if (this_present_locationId || that_present_locationId) {
      if (!(this_present_locationId && that_present_locationId))
        return false;
      if (!this.locationId.equals(that.locationId))
        return false;
    }

    boolean this_present_rowId = true && this.isSetRowId();
    boolean that_present_rowId = true && that.isSetRowId();
    if (this_present_rowId || that_present_rowId) {
      if (!(this_present_rowId && that_present_rowId))
        return false;
      if (!this.rowId.equals(that.rowId))
        return false;
    }

    boolean this_present_recordId = true && this.isSetRecordId();
    boolean that_present_recordId = true && that.isSetRecordId();
    if (this_present_recordId || that_present_recordId) {
      if (!(this_present_recordId && that_present_recordId))
        return false;
      if (!this.recordId.equals(that.recordId))
        return false;
    }

    boolean this_present_columnFamiliesToFetch = true && this.isSetColumnFamiliesToFetch();
    boolean that_present_columnFamiliesToFetch = true && that.isSetColumnFamiliesToFetch();
    if (this_present_columnFamiliesToFetch || that_present_columnFamiliesToFetch) {
      if (!(this_present_columnFamiliesToFetch && that_present_columnFamiliesToFetch))
        return false;
      if (!this.columnFamiliesToFetch.equals(that.columnFamiliesToFetch))
        return false;
    }

    boolean this_present_columnsToFetch = true && this.isSetColumnsToFetch();
    boolean that_present_columnsToFetch = true && that.isSetColumnsToFetch();
    if (this_present_columnsToFetch || that_present_columnsToFetch) {
      if (!(this_present_columnsToFetch && that_present_columnsToFetch))
        return false;
      if (!this.columnsToFetch.equals(that.columnsToFetch))
        return false;
    }

    boolean this_present_allowStaleData = true;
    boolean that_present_allowStaleData = true;
    if (this_present_allowStaleData || that_present_allowStaleData) {
      if (!(this_present_allowStaleData && that_present_allowStaleData))
        return false;
      if (this.allowStaleData != that.allowStaleData)
        return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    return 0;
  }

  public int compareTo(Selector other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;
    Selector typedOther = (Selector)other;

    lastComparison = Boolean.valueOf(isSetRecordOnly()).compareTo(typedOther.isSetRecordOnly());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRecordOnly()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.recordOnly, typedOther.recordOnly);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetLocationId()).compareTo(typedOther.isSetLocationId());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetLocationId()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.locationId, typedOther.locationId);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRowId()).compareTo(typedOther.isSetRowId());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRowId()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.rowId, typedOther.rowId);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRecordId()).compareTo(typedOther.isSetRecordId());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRecordId()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.recordId, typedOther.recordId);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetColumnFamiliesToFetch()).compareTo(typedOther.isSetColumnFamiliesToFetch());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetColumnFamiliesToFetch()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.columnFamiliesToFetch, typedOther.columnFamiliesToFetch);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetColumnsToFetch()).compareTo(typedOther.isSetColumnsToFetch());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetColumnsToFetch()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.columnsToFetch, typedOther.columnsToFetch);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetAllowStaleData()).compareTo(typedOther.isSetAllowStaleData());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetAllowStaleData()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.allowStaleData, typedOther.allowStaleData);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }

  public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
    org.apache.thrift.protocol.TField field;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == org.apache.thrift.protocol.TType.STOP) { 
        break;
      }
      switch (field.id) {
        case 1: // RECORD_ONLY
          if (field.type == org.apache.thrift.protocol.TType.BOOL) {
            this.recordOnly = iprot.readBool();
            setRecordOnlyIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 2: // LOCATION_ID
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.locationId = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 3: // ROW_ID
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.rowId = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 4: // RECORD_ID
          if (field.type == org.apache.thrift.protocol.TType.STRING) {
            this.recordId = iprot.readString();
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 5: // COLUMN_FAMILIES_TO_FETCH
          if (field.type == org.apache.thrift.protocol.TType.SET) {
            {
              org.apache.thrift.protocol.TSet _set8 = iprot.readSetBegin();
              this.columnFamiliesToFetch = new HashSet<String>(2*_set8.size);
              for (int _i9 = 0; _i9 < _set8.size; ++_i9)
              {
                String _elem10; // required
                _elem10 = iprot.readString();
                this.columnFamiliesToFetch.add(_elem10);
              }
              iprot.readSetEnd();
            }
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 6: // COLUMNS_TO_FETCH
          if (field.type == org.apache.thrift.protocol.TType.MAP) {
            {
              org.apache.thrift.protocol.TMap _map11 = iprot.readMapBegin();
              this.columnsToFetch = new HashMap<String,Set<String>>(2*_map11.size);
              for (int _i12 = 0; _i12 < _map11.size; ++_i12)
              {
                String _key13; // required
                Set<String> _val14; // required
                _key13 = iprot.readString();
                {
                  org.apache.thrift.protocol.TSet _set15 = iprot.readSetBegin();
                  _val14 = new HashSet<String>(2*_set15.size);
                  for (int _i16 = 0; _i16 < _set15.size; ++_i16)
                  {
                    String _elem17; // required
                    _elem17 = iprot.readString();
                    _val14.add(_elem17);
                  }
                  iprot.readSetEnd();
                }
                this.columnsToFetch.put(_key13, _val14);
              }
              iprot.readMapEnd();
            }
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case 7: // ALLOW_STALE_DATA
          if (field.type == org.apache.thrift.protocol.TType.BOOL) {
            this.allowStaleData = iprot.readBool();
            setAllowStaleDataIsSet(true);
          } else { 
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();

    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    oprot.writeFieldBegin(RECORD_ONLY_FIELD_DESC);
    oprot.writeBool(this.recordOnly);
    oprot.writeFieldEnd();
    if (this.locationId != null) {
      oprot.writeFieldBegin(LOCATION_ID_FIELD_DESC);
      oprot.writeString(this.locationId);
      oprot.writeFieldEnd();
    }
    if (this.rowId != null) {
      oprot.writeFieldBegin(ROW_ID_FIELD_DESC);
      oprot.writeString(this.rowId);
      oprot.writeFieldEnd();
    }
    if (this.recordId != null) {
      oprot.writeFieldBegin(RECORD_ID_FIELD_DESC);
      oprot.writeString(this.recordId);
      oprot.writeFieldEnd();
    }
    if (this.columnFamiliesToFetch != null) {
      oprot.writeFieldBegin(COLUMN_FAMILIES_TO_FETCH_FIELD_DESC);
      {
        oprot.writeSetBegin(new org.apache.thrift.protocol.TSet(org.apache.thrift.protocol.TType.STRING, this.columnFamiliesToFetch.size()));
        for (String _iter18 : this.columnFamiliesToFetch)
        {
          oprot.writeString(_iter18);
        }
        oprot.writeSetEnd();
      }
      oprot.writeFieldEnd();
    }
    if (this.columnsToFetch != null) {
      oprot.writeFieldBegin(COLUMNS_TO_FETCH_FIELD_DESC);
      {
        oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.SET, this.columnsToFetch.size()));
        for (Map.Entry<String, Set<String>> _iter19 : this.columnsToFetch.entrySet())
        {
          oprot.writeString(_iter19.getKey());
          {
            oprot.writeSetBegin(new org.apache.thrift.protocol.TSet(org.apache.thrift.protocol.TType.STRING, _iter19.getValue().size()));
            for (String _iter20 : _iter19.getValue())
            {
              oprot.writeString(_iter20);
            }
            oprot.writeSetEnd();
          }
        }
        oprot.writeMapEnd();
      }
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(ALLOW_STALE_DATA_FIELD_DESC);
    oprot.writeBool(this.allowStaleData);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder("Selector(");
    boolean first = true;

    sb.append("recordOnly:");
    sb.append(this.recordOnly);
    first = false;
    if (!first) sb.append(", ");
    sb.append("locationId:");
    if (this.locationId == null) {
      sb.append("null");
    } else {
      sb.append(this.locationId);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("rowId:");
    if (this.rowId == null) {
      sb.append("null");
    } else {
      sb.append(this.rowId);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("recordId:");
    if (this.recordId == null) {
      sb.append("null");
    } else {
      sb.append(this.recordId);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("columnFamiliesToFetch:");
    if (this.columnFamiliesToFetch == null) {
      sb.append("null");
    } else {
      sb.append(this.columnFamiliesToFetch);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("columnsToFetch:");
    if (this.columnsToFetch == null) {
      sb.append("null");
    } else {
      sb.append(this.columnsToFetch);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("allowStaleData:");
    sb.append(this.allowStaleData);
    first = false;
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws org.apache.thrift.TException {
    // check for required fields
  }

  private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
    try {
      write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
    try {
      // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
      __isset_bit_vector = new BitSet(1);
      read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

}

