#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

package Blur::ScoreType;
use constant SUPER => 0;
use constant AGGREGATE => 1;
use constant BEST => 2;
use constant CONSTANT => 3;
package Blur::QueryState;
use constant RUNNING => 0;
use constant INTERRUPTED => 1;
use constant COMPLETE => 2;
package Blur::RowMutationType;
use constant DELETE_ROW => 0;
use constant REPLACE_ROW => 1;
use constant UPDATE_ROW => 2;
package Blur::RecordMutationType;
use constant DELETE_ENTIRE_RECORD => 0;
use constant REPLACE_ENTIRE_RECORD => 1;
use constant REPLACE_COLUMNS => 2;
use constant APPEND_COLUMN_VALUES => 3;
package Blur::BlurException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Blur::BlurException->mk_accessors( qw( message stackTraceStr ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  $self->{stackTraceStr} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
    if (defined $vals->{stackTraceStr}) {
      $self->{stackTraceStr} = $vals->{stackTraceStr};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{stackTraceStr});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stackTraceStr}) {
    $xfer += $output->writeFieldBegin('stackTraceStr', TType::STRING, 2);
    $xfer += $output->writeString($self->{stackTraceStr});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Column;
use base qw(Class::Accessor);
Blur::Column->mk_accessors( qw( name value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Column';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Column');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 2);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Record;
use base qw(Class::Accessor);
Blur::Record->mk_accessors( qw( recordId family columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{recordId} = undef;
  $self->{family} = undef;
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{recordId}) {
      $self->{recordId} = $vals->{recordId};
    }
    if (defined $vals->{family}) {
      $self->{family} = $vals->{family};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Record';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{recordId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size0 = 0;
          $self->{columns} = [];
          my $_etype3 = 0;
          $xfer += $input->readListBegin(\$_etype3, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $elem5 = undef;
            $elem5 = new Blur::Column();
            $xfer += $elem5->read($input);
            push(@{$self->{columns}},$elem5);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Record');
  if (defined $self->{recordId}) {
    $xfer += $output->writeFieldBegin('recordId', TType::STRING, 1);
    $xfer += $output->writeString($self->{recordId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{family}) {
    $xfer += $output->writeFieldBegin('family', TType::STRING, 2);
    $xfer += $output->writeString($self->{family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter6 (@{$self->{columns}}) 
        {
          $xfer += ${iter6}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Row;
use base qw(Class::Accessor);
Blur::Row->mk_accessors( qw( id records recordCount ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{id} = undef;
  $self->{records} = undef;
  $self->{recordCount} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{records}) {
      $self->{records} = $vals->{records};
    }
    if (defined $vals->{recordCount}) {
      $self->{recordCount} = $vals->{recordCount};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Row';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size7 = 0;
          $self->{records} = [];
          my $_etype10 = 0;
          $xfer += $input->readListBegin(\$_etype10, \$_size7);
          for (my $_i11 = 0; $_i11 < $_size7; ++$_i11)
          {
            my $elem12 = undef;
            $elem12 = new Blur::Record();
            $xfer += $elem12->read($input);
            push(@{$self->{records}},$elem12);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{recordCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Row');
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
    $xfer += $output->writeString($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{records}) {
    $xfer += $output->writeFieldBegin('records', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{records}}));
      {
        foreach my $iter13 (@{$self->{records}}) 
        {
          $xfer += ${iter13}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordCount}) {
    $xfer += $output->writeFieldBegin('recordCount', TType::I32, 3);
    $xfer += $output->writeI32($self->{recordCount});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Selector;
use base qw(Class::Accessor);
Blur::Selector->mk_accessors( qw( recordOnly locationId rowId recordId columnFamiliesToFetch columnsToFetch allowStaleData ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{recordOnly} = undef;
  $self->{locationId} = undef;
  $self->{rowId} = undef;
  $self->{recordId} = undef;
  $self->{columnFamiliesToFetch} = undef;
  $self->{columnsToFetch} = undef;
  $self->{allowStaleData} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{recordOnly}) {
      $self->{recordOnly} = $vals->{recordOnly};
    }
    if (defined $vals->{locationId}) {
      $self->{locationId} = $vals->{locationId};
    }
    if (defined $vals->{rowId}) {
      $self->{rowId} = $vals->{rowId};
    }
    if (defined $vals->{recordId}) {
      $self->{recordId} = $vals->{recordId};
    }
    if (defined $vals->{columnFamiliesToFetch}) {
      $self->{columnFamiliesToFetch} = $vals->{columnFamiliesToFetch};
    }
    if (defined $vals->{columnsToFetch}) {
      $self->{columnsToFetch} = $vals->{columnsToFetch};
    }
    if (defined $vals->{allowStaleData}) {
      $self->{allowStaleData} = $vals->{allowStaleData};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Selector';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{recordOnly});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{locationId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{rowId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{recordId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::SET) {
        {
          my $_size14 = 0;
          $self->{columnFamiliesToFetch} = {};
          my $_etype17 = 0;
          $xfer += $input->readSetBegin(\$_etype17, \$_size14);
          for (my $_i18 = 0; $_i18 < $_size14; ++$_i18)
          {
            my $elem19 = undef;
            $xfer += $input->readString(\$elem19);
            $self->{columnFamiliesToFetch}->{$elem19} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size20 = 0;
          $self->{columnsToFetch} = {};
          my $_ktype21 = 0;
          my $_vtype22 = 0;
          $xfer += $input->readMapBegin(\$_ktype21, \$_vtype22, \$_size20);
          for (my $_i24 = 0; $_i24 < $_size20; ++$_i24)
          {
            my $key25 = '';
            my $val26 = [];
            $xfer += $input->readString(\$key25);
            {
              my $_size27 = 0;
              $val26 = {};
              my $_etype30 = 0;
              $xfer += $input->readSetBegin(\$_etype30, \$_size27);
              for (my $_i31 = 0; $_i31 < $_size27; ++$_i31)
              {
                my $elem32 = undef;
                $xfer += $input->readString(\$elem32);
                $val26->{$elem32} = 1;
              }
              $xfer += $input->readSetEnd();
            }
            $self->{columnsToFetch}->{$key25} = $val26;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{allowStaleData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Selector');
  if (defined $self->{recordOnly}) {
    $xfer += $output->writeFieldBegin('recordOnly', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{recordOnly});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{locationId}) {
    $xfer += $output->writeFieldBegin('locationId', TType::STRING, 2);
    $xfer += $output->writeString($self->{locationId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowId}) {
    $xfer += $output->writeFieldBegin('rowId', TType::STRING, 3);
    $xfer += $output->writeString($self->{rowId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordId}) {
    $xfer += $output->writeFieldBegin('recordId', TType::STRING, 4);
    $xfer += $output->writeString($self->{recordId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamiliesToFetch}) {
    $xfer += $output->writeFieldBegin('columnFamiliesToFetch', TType::SET, 5);
    {
      $xfer += $output->writeSetBegin(TType::STRING, scalar(@{$self->{columnFamiliesToFetch}}));
      {
        foreach my $iter33 (@{$self->{columnFamiliesToFetch}})
        {
          $xfer += $output->writeString($iter33);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnsToFetch}) {
    $xfer += $output->writeFieldBegin('columnsToFetch', TType::MAP, 6);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::SET, scalar(keys %{$self->{columnsToFetch}}));
      {
        while( my ($kiter34,$viter35) = each %{$self->{columnsToFetch}}) 
        {
          $xfer += $output->writeString($kiter34);
          {
            $xfer += $output->writeSetBegin(TType::STRING, scalar(@{${viter35}}));
            {
              foreach my $iter36 (@{${viter35}})
              {
                $xfer += $output->writeString($iter36);
              }
            }
            $xfer += $output->writeSetEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{allowStaleData}) {
    $xfer += $output->writeFieldBegin('allowStaleData', TType::BOOL, 7);
    $xfer += $output->writeBool($self->{allowStaleData});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::FetchRowResult;
use base qw(Class::Accessor);
Blur::FetchRowResult->mk_accessors( qw( row ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{row} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'FetchRowResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{row} = new Blur::Row();
        $xfer += $self->{row}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('FetchRowResult');
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRUCT, 1);
    $xfer += $self->{row}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::FetchRecordResult;
use base qw(Class::Accessor);
Blur::FetchRecordResult->mk_accessors( qw( rowid record ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{rowid} = undef;
  $self->{record} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{rowid}) {
      $self->{rowid} = $vals->{rowid};
    }
    if (defined $vals->{record}) {
      $self->{record} = $vals->{record};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'FetchRecordResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{rowid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{record} = new Blur::Record();
        $xfer += $self->{record}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('FetchRecordResult');
  if (defined $self->{rowid}) {
    $xfer += $output->writeFieldBegin('rowid', TType::STRING, 1);
    $xfer += $output->writeString($self->{rowid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{record}) {
    $xfer += $output->writeFieldBegin('record', TType::STRUCT, 2);
    $xfer += $self->{record}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::FetchResult;
use base qw(Class::Accessor);
Blur::FetchResult->mk_accessors( qw( exists deleted table rowResult recordResult ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{exists} = undef;
  $self->{deleted} = undef;
  $self->{table} = undef;
  $self->{rowResult} = undef;
  $self->{recordResult} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{exists}) {
      $self->{exists} = $vals->{exists};
    }
    if (defined $vals->{deleted}) {
      $self->{deleted} = $vals->{deleted};
    }
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{rowResult}) {
      $self->{rowResult} = $vals->{rowResult};
    }
    if (defined $vals->{recordResult}) {
      $self->{recordResult} = $vals->{recordResult};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'FetchResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{exists});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleted});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{rowResult} = new Blur::FetchRowResult();
        $xfer += $self->{rowResult}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{recordResult} = new Blur::FetchRecordResult();
        $xfer += $self->{recordResult}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('FetchResult');
  if (defined $self->{exists}) {
    $xfer += $output->writeFieldBegin('exists', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{exists});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleted}) {
    $xfer += $output->writeFieldBegin('deleted', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{deleted});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 3);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowResult}) {
    $xfer += $output->writeFieldBegin('rowResult', TType::STRUCT, 4);
    $xfer += $self->{rowResult}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordResult}) {
    $xfer += $output->writeFieldBegin('recordResult', TType::STRUCT, 5);
    $xfer += $self->{recordResult}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::SimpleQuery;
use base qw(Class::Accessor);
Blur::SimpleQuery->mk_accessors( qw( queryStr superQueryOn type postSuperFilter preSuperFilter ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{queryStr} = undef;
  $self->{superQueryOn} = 1;
  $self->{type} = 0;
  $self->{postSuperFilter} = undef;
  $self->{preSuperFilter} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{queryStr}) {
      $self->{queryStr} = $vals->{queryStr};
    }
    if (defined $vals->{superQueryOn}) {
      $self->{superQueryOn} = $vals->{superQueryOn};
    }
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
    if (defined $vals->{postSuperFilter}) {
      $self->{postSuperFilter} = $vals->{postSuperFilter};
    }
    if (defined $vals->{preSuperFilter}) {
      $self->{preSuperFilter} = $vals->{preSuperFilter};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SimpleQuery';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{queryStr});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{superQueryOn});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{postSuperFilter});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{preSuperFilter});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SimpleQuery');
  if (defined $self->{queryStr}) {
    $xfer += $output->writeFieldBegin('queryStr', TType::STRING, 1);
    $xfer += $output->writeString($self->{queryStr});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{superQueryOn}) {
    $xfer += $output->writeFieldBegin('superQueryOn', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{superQueryOn});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::I32, 3);
    $xfer += $output->writeI32($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{postSuperFilter}) {
    $xfer += $output->writeFieldBegin('postSuperFilter', TType::STRING, 4);
    $xfer += $output->writeString($self->{postSuperFilter});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{preSuperFilter}) {
    $xfer += $output->writeFieldBegin('preSuperFilter', TType::STRING, 5);
    $xfer += $output->writeString($self->{preSuperFilter});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::ExpertQuery;
use base qw(Class::Accessor);
Blur::ExpertQuery->mk_accessors( qw( query filter ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{query} = undef;
  $self->{filter} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{filter}) {
      $self->{filter} = $vals->{filter};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ExpertQuery';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{query});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{filter});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ExpertQuery');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRING, 1);
    $xfer += $output->writeString($self->{query});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{filter}) {
    $xfer += $output->writeFieldBegin('filter', TType::STRING, 2);
    $xfer += $output->writeString($self->{filter});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Facet;
use base qw(Class::Accessor);
Blur::Facet->mk_accessors( qw( queryStr minimumNumberOfBlurResults ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{queryStr} = undef;
  $self->{minimumNumberOfBlurResults} = 9223372036854775807;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{queryStr}) {
      $self->{queryStr} = $vals->{queryStr};
    }
    if (defined $vals->{minimumNumberOfBlurResults}) {
      $self->{minimumNumberOfBlurResults} = $vals->{minimumNumberOfBlurResults};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Facet';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{queryStr});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{minimumNumberOfBlurResults});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Facet');
  if (defined $self->{queryStr}) {
    $xfer += $output->writeFieldBegin('queryStr', TType::STRING, 1);
    $xfer += $output->writeString($self->{queryStr});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{minimumNumberOfBlurResults}) {
    $xfer += $output->writeFieldBegin('minimumNumberOfBlurResults', TType::I64, 2);
    $xfer += $output->writeI64($self->{minimumNumberOfBlurResults});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurQuery;
use base qw(Class::Accessor);
Blur::BlurQuery->mk_accessors( qw( simpleQuery expertQuery facets selector allowStaleData useCacheIfPresent start fetch minimumNumberOfResults maxQueryTime uuid userContext cacheResult startTime modifyFileCaches ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{simpleQuery} = undef;
  $self->{expertQuery} = undef;
  $self->{facets} = undef;
  $self->{selector} = undef;
  $self->{allowStaleData} = 0;
  $self->{useCacheIfPresent} = 1;
  $self->{start} = 0;
  $self->{fetch} = 10;
  $self->{minimumNumberOfResults} = 9223372036854775807;
  $self->{maxQueryTime} = 9223372036854775807;
  $self->{uuid} = undef;
  $self->{userContext} = undef;
  $self->{cacheResult} = 1;
  $self->{startTime} = 0;
  $self->{modifyFileCaches} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{simpleQuery}) {
      $self->{simpleQuery} = $vals->{simpleQuery};
    }
    if (defined $vals->{expertQuery}) {
      $self->{expertQuery} = $vals->{expertQuery};
    }
    if (defined $vals->{facets}) {
      $self->{facets} = $vals->{facets};
    }
    if (defined $vals->{selector}) {
      $self->{selector} = $vals->{selector};
    }
    if (defined $vals->{allowStaleData}) {
      $self->{allowStaleData} = $vals->{allowStaleData};
    }
    if (defined $vals->{useCacheIfPresent}) {
      $self->{useCacheIfPresent} = $vals->{useCacheIfPresent};
    }
    if (defined $vals->{start}) {
      $self->{start} = $vals->{start};
    }
    if (defined $vals->{fetch}) {
      $self->{fetch} = $vals->{fetch};
    }
    if (defined $vals->{minimumNumberOfResults}) {
      $self->{minimumNumberOfResults} = $vals->{minimumNumberOfResults};
    }
    if (defined $vals->{maxQueryTime}) {
      $self->{maxQueryTime} = $vals->{maxQueryTime};
    }
    if (defined $vals->{uuid}) {
      $self->{uuid} = $vals->{uuid};
    }
    if (defined $vals->{userContext}) {
      $self->{userContext} = $vals->{userContext};
    }
    if (defined $vals->{cacheResult}) {
      $self->{cacheResult} = $vals->{cacheResult};
    }
    if (defined $vals->{startTime}) {
      $self->{startTime} = $vals->{startTime};
    }
    if (defined $vals->{modifyFileCaches}) {
      $self->{modifyFileCaches} = $vals->{modifyFileCaches};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurQuery';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{simpleQuery} = new Blur::SimpleQuery();
        $xfer += $self->{simpleQuery}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{expertQuery} = new Blur::ExpertQuery();
        $xfer += $self->{expertQuery}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size37 = 0;
          $self->{facets} = [];
          my $_etype40 = 0;
          $xfer += $input->readListBegin(\$_etype40, \$_size37);
          for (my $_i41 = 0; $_i41 < $_size37; ++$_i41)
          {
            my $elem42 = undef;
            $elem42 = new Blur::Facet();
            $xfer += $elem42->read($input);
            push(@{$self->{facets}},$elem42);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{selector} = new Blur::Selector();
        $xfer += $self->{selector}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{allowStaleData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{useCacheIfPresent});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{start});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{fetch});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{minimumNumberOfResults});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{maxQueryTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{uuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{userContext});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{cacheResult});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{startTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^15$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{modifyFileCaches});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurQuery');
  if (defined $self->{simpleQuery}) {
    $xfer += $output->writeFieldBegin('simpleQuery', TType::STRUCT, 1);
    $xfer += $self->{simpleQuery}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{expertQuery}) {
    $xfer += $output->writeFieldBegin('expertQuery', TType::STRUCT, 2);
    $xfer += $self->{expertQuery}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{facets}) {
    $xfer += $output->writeFieldBegin('facets', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{facets}}));
      {
        foreach my $iter43 (@{$self->{facets}}) 
        {
          $xfer += ${iter43}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{selector}) {
    $xfer += $output->writeFieldBegin('selector', TType::STRUCT, 4);
    $xfer += $self->{selector}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{allowStaleData}) {
    $xfer += $output->writeFieldBegin('allowStaleData', TType::BOOL, 5);
    $xfer += $output->writeBool($self->{allowStaleData});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{useCacheIfPresent}) {
    $xfer += $output->writeFieldBegin('useCacheIfPresent', TType::BOOL, 6);
    $xfer += $output->writeBool($self->{useCacheIfPresent});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start}) {
    $xfer += $output->writeFieldBegin('start', TType::I64, 7);
    $xfer += $output->writeI64($self->{start});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fetch}) {
    $xfer += $output->writeFieldBegin('fetch', TType::I32, 8);
    $xfer += $output->writeI32($self->{fetch});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{minimumNumberOfResults}) {
    $xfer += $output->writeFieldBegin('minimumNumberOfResults', TType::I64, 9);
    $xfer += $output->writeI64($self->{minimumNumberOfResults});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{maxQueryTime}) {
    $xfer += $output->writeFieldBegin('maxQueryTime', TType::I64, 10);
    $xfer += $output->writeI64($self->{maxQueryTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uuid}) {
    $xfer += $output->writeFieldBegin('uuid', TType::I64, 11);
    $xfer += $output->writeI64($self->{uuid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userContext}) {
    $xfer += $output->writeFieldBegin('userContext', TType::STRING, 12);
    $xfer += $output->writeString($self->{userContext});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cacheResult}) {
    $xfer += $output->writeFieldBegin('cacheResult', TType::BOOL, 13);
    $xfer += $output->writeBool($self->{cacheResult});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startTime}) {
    $xfer += $output->writeFieldBegin('startTime', TType::I64, 14);
    $xfer += $output->writeI64($self->{startTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{modifyFileCaches}) {
    $xfer += $output->writeFieldBegin('modifyFileCaches', TType::BOOL, 15);
    $xfer += $output->writeBool($self->{modifyFileCaches});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurResult;
use base qw(Class::Accessor);
Blur::BlurResult->mk_accessors( qw( locationId score fetchResult ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{locationId} = undef;
  $self->{score} = undef;
  $self->{fetchResult} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{locationId}) {
      $self->{locationId} = $vals->{locationId};
    }
    if (defined $vals->{score}) {
      $self->{score} = $vals->{score};
    }
    if (defined $vals->{fetchResult}) {
      $self->{fetchResult} = $vals->{fetchResult};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{locationId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{score});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{fetchResult} = new Blur::FetchResult();
        $xfer += $self->{fetchResult}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurResult');
  if (defined $self->{locationId}) {
    $xfer += $output->writeFieldBegin('locationId', TType::STRING, 1);
    $xfer += $output->writeString($self->{locationId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{score}) {
    $xfer += $output->writeFieldBegin('score', TType::DOUBLE, 2);
    $xfer += $output->writeDouble($self->{score});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fetchResult}) {
    $xfer += $output->writeFieldBegin('fetchResult', TType::STRUCT, 3);
    $xfer += $self->{fetchResult}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurResults;
use base qw(Class::Accessor);
Blur::BlurResults->mk_accessors( qw( totalResults shardInfo results facetCounts exceptions query ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{totalResults} = 0;
  $self->{shardInfo} = undef;
  $self->{results} = undef;
  $self->{facetCounts} = undef;
  $self->{exceptions} = undef;
  $self->{query} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{totalResults}) {
      $self->{totalResults} = $vals->{totalResults};
    }
    if (defined $vals->{shardInfo}) {
      $self->{shardInfo} = $vals->{shardInfo};
    }
    if (defined $vals->{results}) {
      $self->{results} = $vals->{results};
    }
    if (defined $vals->{facetCounts}) {
      $self->{facetCounts} = $vals->{facetCounts};
    }
    if (defined $vals->{exceptions}) {
      $self->{exceptions} = $vals->{exceptions};
    }
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurResults';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{totalResults});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size44 = 0;
          $self->{shardInfo} = {};
          my $_ktype45 = 0;
          my $_vtype46 = 0;
          $xfer += $input->readMapBegin(\$_ktype45, \$_vtype46, \$_size44);
          for (my $_i48 = 0; $_i48 < $_size44; ++$_i48)
          {
            my $key49 = '';
            my $val50 = 0;
            $xfer += $input->readString(\$key49);
            $xfer += $input->readI64(\$val50);
            $self->{shardInfo}->{$key49} = $val50;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size51 = 0;
          $self->{results} = [];
          my $_etype54 = 0;
          $xfer += $input->readListBegin(\$_etype54, \$_size51);
          for (my $_i55 = 0; $_i55 < $_size51; ++$_i55)
          {
            my $elem56 = undef;
            $elem56 = new Blur::BlurResult();
            $xfer += $elem56->read($input);
            push(@{$self->{results}},$elem56);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size57 = 0;
          $self->{facetCounts} = [];
          my $_etype60 = 0;
          $xfer += $input->readListBegin(\$_etype60, \$_size57);
          for (my $_i61 = 0; $_i61 < $_size57; ++$_i61)
          {
            my $elem62 = undef;
            $xfer += $input->readI64(\$elem62);
            push(@{$self->{facetCounts}},$elem62);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size63 = 0;
          $self->{exceptions} = [];
          my $_etype66 = 0;
          $xfer += $input->readListBegin(\$_etype66, \$_size63);
          for (my $_i67 = 0; $_i67 < $_size63; ++$_i67)
          {
            my $elem68 = undef;
            $elem68 = new Blur::BlurException();
            $xfer += $elem68->read($input);
            push(@{$self->{exceptions}},$elem68);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{query} = new Blur::BlurQuery();
        $xfer += $self->{query}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurResults');
  if (defined $self->{totalResults}) {
    $xfer += $output->writeFieldBegin('totalResults', TType::I64, 1);
    $xfer += $output->writeI64($self->{totalResults});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{shardInfo}) {
    $xfer += $output->writeFieldBegin('shardInfo', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::I64, scalar(keys %{$self->{shardInfo}}));
      {
        while( my ($kiter69,$viter70) = each %{$self->{shardInfo}}) 
        {
          $xfer += $output->writeString($kiter69);
          $xfer += $output->writeI64($viter70);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{results}) {
    $xfer += $output->writeFieldBegin('results', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{results}}));
      {
        foreach my $iter71 (@{$self->{results}}) 
        {
          $xfer += ${iter71}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{facetCounts}) {
    $xfer += $output->writeFieldBegin('facetCounts', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::I64, scalar(@{$self->{facetCounts}}));
      {
        foreach my $iter72 (@{$self->{facetCounts}}) 
        {
          $xfer += $output->writeI64($iter72);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{exceptions}) {
    $xfer += $output->writeFieldBegin('exceptions', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{exceptions}}));
      {
        foreach my $iter73 (@{$self->{exceptions}}) 
        {
          $xfer += ${iter73}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRUCT, 6);
    $xfer += $self->{query}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::RecordMutation;
use base qw(Class::Accessor);
Blur::RecordMutation->mk_accessors( qw( recordMutationType record ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{recordMutationType} = undef;
  $self->{record} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{recordMutationType}) {
      $self->{recordMutationType} = $vals->{recordMutationType};
    }
    if (defined $vals->{record}) {
      $self->{record} = $vals->{record};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecordMutation';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{recordMutationType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{record} = new Blur::Record();
        $xfer += $self->{record}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecordMutation');
  if (defined $self->{recordMutationType}) {
    $xfer += $output->writeFieldBegin('recordMutationType', TType::I32, 1);
    $xfer += $output->writeI32($self->{recordMutationType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{record}) {
    $xfer += $output->writeFieldBegin('record', TType::STRUCT, 2);
    $xfer += $self->{record}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::RowMutation;
use base qw(Class::Accessor);
Blur::RowMutation->mk_accessors( qw( table rowId wal rowMutationType recordMutations waitToBeVisible ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{rowId} = undef;
  $self->{wal} = 1;
  $self->{rowMutationType} = undef;
  $self->{recordMutations} = undef;
  $self->{waitToBeVisible} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{rowId}) {
      $self->{rowId} = $vals->{rowId};
    }
    if (defined $vals->{wal}) {
      $self->{wal} = $vals->{wal};
    }
    if (defined $vals->{rowMutationType}) {
      $self->{rowMutationType} = $vals->{rowMutationType};
    }
    if (defined $vals->{recordMutations}) {
      $self->{recordMutations} = $vals->{recordMutations};
    }
    if (defined $vals->{waitToBeVisible}) {
      $self->{waitToBeVisible} = $vals->{waitToBeVisible};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RowMutation';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{rowId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{wal});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{rowMutationType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size74 = 0;
          $self->{recordMutations} = [];
          my $_etype77 = 0;
          $xfer += $input->readListBegin(\$_etype77, \$_size74);
          for (my $_i78 = 0; $_i78 < $_size74; ++$_i78)
          {
            my $elem79 = undef;
            $elem79 = new Blur::RecordMutation();
            $xfer += $elem79->read($input);
            push(@{$self->{recordMutations}},$elem79);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{waitToBeVisible});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RowMutation');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowId}) {
    $xfer += $output->writeFieldBegin('rowId', TType::STRING, 2);
    $xfer += $output->writeString($self->{rowId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{wal}) {
    $xfer += $output->writeFieldBegin('wal', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{wal});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowMutationType}) {
    $xfer += $output->writeFieldBegin('rowMutationType', TType::I32, 4);
    $xfer += $output->writeI32($self->{rowMutationType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordMutations}) {
    $xfer += $output->writeFieldBegin('recordMutations', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{recordMutations}}));
      {
        foreach my $iter80 (@{$self->{recordMutations}}) 
        {
          $xfer += ${iter80}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{waitToBeVisible}) {
    $xfer += $output->writeFieldBegin('waitToBeVisible', TType::BOOL, 6);
    $xfer += $output->writeBool($self->{waitToBeVisible});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::CpuTime;
use base qw(Class::Accessor);
Blur::CpuTime->mk_accessors( qw( cpuTime realTime ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cpuTime} = undef;
  $self->{realTime} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cpuTime}) {
      $self->{cpuTime} = $vals->{cpuTime};
    }
    if (defined $vals->{realTime}) {
      $self->{realTime} = $vals->{realTime};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CpuTime';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{cpuTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{realTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CpuTime');
  if (defined $self->{cpuTime}) {
    $xfer += $output->writeFieldBegin('cpuTime', TType::I64, 1);
    $xfer += $output->writeI64($self->{cpuTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{realTime}) {
    $xfer += $output->writeFieldBegin('realTime', TType::I64, 2);
    $xfer += $output->writeI64($self->{realTime});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurQueryStatus;
use base qw(Class::Accessor);
Blur::BlurQueryStatus->mk_accessors( qw( query cpuTimes completeShards totalShards state uuid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{query} = undef;
  $self->{cpuTimes} = undef;
  $self->{completeShards} = undef;
  $self->{totalShards} = undef;
  $self->{state} = undef;
  $self->{uuid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{cpuTimes}) {
      $self->{cpuTimes} = $vals->{cpuTimes};
    }
    if (defined $vals->{completeShards}) {
      $self->{completeShards} = $vals->{completeShards};
    }
    if (defined $vals->{totalShards}) {
      $self->{totalShards} = $vals->{totalShards};
    }
    if (defined $vals->{state}) {
      $self->{state} = $vals->{state};
    }
    if (defined $vals->{uuid}) {
      $self->{uuid} = $vals->{uuid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurQueryStatus';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{query} = new Blur::BlurQuery();
        $xfer += $self->{query}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size81 = 0;
          $self->{cpuTimes} = {};
          my $_ktype82 = 0;
          my $_vtype83 = 0;
          $xfer += $input->readMapBegin(\$_ktype82, \$_vtype83, \$_size81);
          for (my $_i85 = 0; $_i85 < $_size81; ++$_i85)
          {
            my $key86 = '';
            my $val87 = new Blur::CpuTime();
            $xfer += $input->readString(\$key86);
            $val87 = new Blur::CpuTime();
            $xfer += $val87->read($input);
            $self->{cpuTimes}->{$key86} = $val87;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{completeShards});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{totalShards});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{state});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{uuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurQueryStatus');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRUCT, 1);
    $xfer += $self->{query}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cpuTimes}) {
    $xfer += $output->writeFieldBegin('cpuTimes', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{cpuTimes}}));
      {
        while( my ($kiter88,$viter89) = each %{$self->{cpuTimes}}) 
        {
          $xfer += $output->writeString($kiter88);
          $xfer += ${viter89}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{completeShards}) {
    $xfer += $output->writeFieldBegin('completeShards', TType::I32, 3);
    $xfer += $output->writeI32($self->{completeShards});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{totalShards}) {
    $xfer += $output->writeFieldBegin('totalShards', TType::I32, 4);
    $xfer += $output->writeI32($self->{totalShards});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{state}) {
    $xfer += $output->writeFieldBegin('state', TType::I32, 5);
    $xfer += $output->writeI32($self->{state});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uuid}) {
    $xfer += $output->writeFieldBegin('uuid', TType::I64, 6);
    $xfer += $output->writeI64($self->{uuid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::TableStats;
use base qw(Class::Accessor);
Blur::TableStats->mk_accessors( qw( tableName bytes recordCount rowCount queries ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{bytes} = undef;
  $self->{recordCount} = undef;
  $self->{rowCount} = undef;
  $self->{queries} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{bytes}) {
      $self->{bytes} = $vals->{bytes};
    }
    if (defined $vals->{recordCount}) {
      $self->{recordCount} = $vals->{recordCount};
    }
    if (defined $vals->{rowCount}) {
      $self->{rowCount} = $vals->{rowCount};
    }
    if (defined $vals->{queries}) {
      $self->{queries} = $vals->{queries};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TableStats';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{bytes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{recordCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{rowCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{queries});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TableStats');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{bytes}) {
    $xfer += $output->writeFieldBegin('bytes', TType::I64, 2);
    $xfer += $output->writeI64($self->{bytes});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordCount}) {
    $xfer += $output->writeFieldBegin('recordCount', TType::I64, 3);
    $xfer += $output->writeI64($self->{recordCount});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowCount}) {
    $xfer += $output->writeFieldBegin('rowCount', TType::I64, 4);
    $xfer += $output->writeI64($self->{rowCount});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{queries}) {
    $xfer += $output->writeFieldBegin('queries', TType::I64, 5);
    $xfer += $output->writeI64($self->{queries});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Schema;
use base qw(Class::Accessor);
Blur::Schema->mk_accessors( qw( table columnFamilies ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{columnFamilies} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{columnFamilies}) {
      $self->{columnFamilies} = $vals->{columnFamilies};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Schema';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size90 = 0;
          $self->{columnFamilies} = {};
          my $_ktype91 = 0;
          my $_vtype92 = 0;
          $xfer += $input->readMapBegin(\$_ktype91, \$_vtype92, \$_size90);
          for (my $_i94 = 0; $_i94 < $_size90; ++$_i94)
          {
            my $key95 = '';
            my $val96 = [];
            $xfer += $input->readString(\$key95);
            {
              my $_size97 = 0;
              $val96 = {};
              my $_etype100 = 0;
              $xfer += $input->readSetBegin(\$_etype100, \$_size97);
              for (my $_i101 = 0; $_i101 < $_size97; ++$_i101)
              {
                my $elem102 = undef;
                $xfer += $input->readString(\$elem102);
                $val96->{$elem102} = 1;
              }
              $xfer += $input->readSetEnd();
            }
            $self->{columnFamilies}->{$key95} = $val96;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Schema');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamilies}) {
    $xfer += $output->writeFieldBegin('columnFamilies', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::SET, scalar(keys %{$self->{columnFamilies}}));
      {
        while( my ($kiter103,$viter104) = each %{$self->{columnFamilies}}) 
        {
          $xfer += $output->writeString($kiter103);
          {
            $xfer += $output->writeSetBegin(TType::STRING, scalar(@{${viter104}}));
            {
              foreach my $iter105 (@{${viter104}})
              {
                $xfer += $output->writeString($iter105);
              }
            }
            $xfer += $output->writeSetEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::AlternateColumnDefinition;
use base qw(Class::Accessor);
Blur::AlternateColumnDefinition->mk_accessors( qw( analyzerClassName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{analyzerClassName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{analyzerClassName}) {
      $self->{analyzerClassName} = $vals->{analyzerClassName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AlternateColumnDefinition';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{analyzerClassName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AlternateColumnDefinition');
  if (defined $self->{analyzerClassName}) {
    $xfer += $output->writeFieldBegin('analyzerClassName', TType::STRING, 1);
    $xfer += $output->writeString($self->{analyzerClassName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::ColumnDefinition;
use base qw(Class::Accessor);
Blur::ColumnDefinition->mk_accessors( qw( analyzerClassName fullTextIndex alternateColumnDefinitions ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{analyzerClassName} = "org.apache.lucene.analysis.standard.StandardAnalyzer";
  $self->{fullTextIndex} = undef;
  $self->{alternateColumnDefinitions} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{analyzerClassName}) {
      $self->{analyzerClassName} = $vals->{analyzerClassName};
    }
    if (defined $vals->{fullTextIndex}) {
      $self->{fullTextIndex} = $vals->{fullTextIndex};
    }
    if (defined $vals->{alternateColumnDefinitions}) {
      $self->{alternateColumnDefinitions} = $vals->{alternateColumnDefinitions};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnDefinition';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{analyzerClassName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{fullTextIndex});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size106 = 0;
          $self->{alternateColumnDefinitions} = {};
          my $_ktype107 = 0;
          my $_vtype108 = 0;
          $xfer += $input->readMapBegin(\$_ktype107, \$_vtype108, \$_size106);
          for (my $_i110 = 0; $_i110 < $_size106; ++$_i110)
          {
            my $key111 = '';
            my $val112 = new Blur::AlternateColumnDefinition();
            $xfer += $input->readString(\$key111);
            $val112 = new Blur::AlternateColumnDefinition();
            $xfer += $val112->read($input);
            $self->{alternateColumnDefinitions}->{$key111} = $val112;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnDefinition');
  if (defined $self->{analyzerClassName}) {
    $xfer += $output->writeFieldBegin('analyzerClassName', TType::STRING, 1);
    $xfer += $output->writeString($self->{analyzerClassName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fullTextIndex}) {
    $xfer += $output->writeFieldBegin('fullTextIndex', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{fullTextIndex});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{alternateColumnDefinitions}) {
    $xfer += $output->writeFieldBegin('alternateColumnDefinitions', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{alternateColumnDefinitions}}));
      {
        while( my ($kiter113,$viter114) = each %{$self->{alternateColumnDefinitions}}) 
        {
          $xfer += $output->writeString($kiter113);
          $xfer += ${viter114}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::ColumnFamilyDefinition;
use base qw(Class::Accessor);
Blur::ColumnFamilyDefinition->mk_accessors( qw( defaultDefinition columnDefinitions ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{defaultDefinition} = undef;
  $self->{columnDefinitions} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{defaultDefinition}) {
      $self->{defaultDefinition} = $vals->{defaultDefinition};
    }
    if (defined $vals->{columnDefinitions}) {
      $self->{columnDefinitions} = $vals->{columnDefinitions};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnFamilyDefinition';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{defaultDefinition} = new Blur::ColumnDefinition();
        $xfer += $self->{defaultDefinition}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size115 = 0;
          $self->{columnDefinitions} = {};
          my $_ktype116 = 0;
          my $_vtype117 = 0;
          $xfer += $input->readMapBegin(\$_ktype116, \$_vtype117, \$_size115);
          for (my $_i119 = 0; $_i119 < $_size115; ++$_i119)
          {
            my $key120 = '';
            my $val121 = new Blur::ColumnDefinition();
            $xfer += $input->readString(\$key120);
            $val121 = new Blur::ColumnDefinition();
            $xfer += $val121->read($input);
            $self->{columnDefinitions}->{$key120} = $val121;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnFamilyDefinition');
  if (defined $self->{defaultDefinition}) {
    $xfer += $output->writeFieldBegin('defaultDefinition', TType::STRUCT, 1);
    $xfer += $self->{defaultDefinition}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnDefinitions}) {
    $xfer += $output->writeFieldBegin('columnDefinitions', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{columnDefinitions}}));
      {
        while( my ($kiter122,$viter123) = each %{$self->{columnDefinitions}}) 
        {
          $xfer += $output->writeString($kiter122);
          $xfer += ${viter123}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::AnalyzerDefinition;
use base qw(Class::Accessor);
Blur::AnalyzerDefinition->mk_accessors( qw( defaultDefinition fullTextAnalyzerClassName columnFamilyDefinitions ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{defaultDefinition} = undef;
  $self->{fullTextAnalyzerClassName} = "org.apache.lucene.analysis.standard.StandardAnalyzer";
  $self->{columnFamilyDefinitions} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{defaultDefinition}) {
      $self->{defaultDefinition} = $vals->{defaultDefinition};
    }
    if (defined $vals->{fullTextAnalyzerClassName}) {
      $self->{fullTextAnalyzerClassName} = $vals->{fullTextAnalyzerClassName};
    }
    if (defined $vals->{columnFamilyDefinitions}) {
      $self->{columnFamilyDefinitions} = $vals->{columnFamilyDefinitions};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AnalyzerDefinition';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{defaultDefinition} = new Blur::ColumnDefinition();
        $xfer += $self->{defaultDefinition}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{fullTextAnalyzerClassName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size124 = 0;
          $self->{columnFamilyDefinitions} = {};
          my $_ktype125 = 0;
          my $_vtype126 = 0;
          $xfer += $input->readMapBegin(\$_ktype125, \$_vtype126, \$_size124);
          for (my $_i128 = 0; $_i128 < $_size124; ++$_i128)
          {
            my $key129 = '';
            my $val130 = new Blur::ColumnFamilyDefinition();
            $xfer += $input->readString(\$key129);
            $val130 = new Blur::ColumnFamilyDefinition();
            $xfer += $val130->read($input);
            $self->{columnFamilyDefinitions}->{$key129} = $val130;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AnalyzerDefinition');
  if (defined $self->{defaultDefinition}) {
    $xfer += $output->writeFieldBegin('defaultDefinition', TType::STRUCT, 1);
    $xfer += $self->{defaultDefinition}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fullTextAnalyzerClassName}) {
    $xfer += $output->writeFieldBegin('fullTextAnalyzerClassName', TType::STRING, 2);
    $xfer += $output->writeString($self->{fullTextAnalyzerClassName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamilyDefinitions}) {
    $xfer += $output->writeFieldBegin('columnFamilyDefinitions', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{columnFamilyDefinitions}}));
      {
        while( my ($kiter131,$viter132) = each %{$self->{columnFamilyDefinitions}}) 
        {
          $xfer += $output->writeString($kiter131);
          $xfer += ${viter132}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::ColumnPreCache;
use base qw(Class::Accessor);
Blur::ColumnPreCache->mk_accessors( qw( preCacheCols ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{preCacheCols} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{preCacheCols}) {
      $self->{preCacheCols} = $vals->{preCacheCols};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnPreCache';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size133 = 0;
          $self->{preCacheCols} = [];
          my $_etype136 = 0;
          $xfer += $input->readListBegin(\$_etype136, \$_size133);
          for (my $_i137 = 0; $_i137 < $_size133; ++$_i137)
          {
            my $elem138 = undef;
            $xfer += $input->readString(\$elem138);
            push(@{$self->{preCacheCols}},$elem138);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnPreCache');
  if (defined $self->{preCacheCols}) {
    $xfer += $output->writeFieldBegin('preCacheCols', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{preCacheCols}}));
      {
        foreach my $iter139 (@{$self->{preCacheCols}}) 
        {
          $xfer += $output->writeString($iter139);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::TableDescriptor;
use base qw(Class::Accessor);
Blur::TableDescriptor->mk_accessors( qw( isEnabled analyzerDefinition shardCount tableUri compressionClass compressionBlockSize cluster name similarityClass blockCaching blockCachingFileTypes readOnly columnPreCache tableProperties ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{isEnabled} = 1;
  $self->{analyzerDefinition} = undef;
  $self->{shardCount} = 1;
  $self->{tableUri} = undef;
  $self->{compressionClass} = "org.apache.hadoop.io.compress.DefaultCodec";
  $self->{compressionBlockSize} = 32768;
  $self->{cluster} = "default";
  $self->{name} = undef;
  $self->{similarityClass} = undef;
  $self->{blockCaching} = 1;
  $self->{blockCachingFileTypes} = undef;
  $self->{readOnly} = 0;
  $self->{columnPreCache} = undef;
  $self->{tableProperties} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{isEnabled}) {
      $self->{isEnabled} = $vals->{isEnabled};
    }
    if (defined $vals->{analyzerDefinition}) {
      $self->{analyzerDefinition} = $vals->{analyzerDefinition};
    }
    if (defined $vals->{shardCount}) {
      $self->{shardCount} = $vals->{shardCount};
    }
    if (defined $vals->{tableUri}) {
      $self->{tableUri} = $vals->{tableUri};
    }
    if (defined $vals->{compressionClass}) {
      $self->{compressionClass} = $vals->{compressionClass};
    }
    if (defined $vals->{compressionBlockSize}) {
      $self->{compressionBlockSize} = $vals->{compressionBlockSize};
    }
    if (defined $vals->{cluster}) {
      $self->{cluster} = $vals->{cluster};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{similarityClass}) {
      $self->{similarityClass} = $vals->{similarityClass};
    }
    if (defined $vals->{blockCaching}) {
      $self->{blockCaching} = $vals->{blockCaching};
    }
    if (defined $vals->{blockCachingFileTypes}) {
      $self->{blockCachingFileTypes} = $vals->{blockCachingFileTypes};
    }
    if (defined $vals->{readOnly}) {
      $self->{readOnly} = $vals->{readOnly};
    }
    if (defined $vals->{columnPreCache}) {
      $self->{columnPreCache} = $vals->{columnPreCache};
    }
    if (defined $vals->{tableProperties}) {
      $self->{tableProperties} = $vals->{tableProperties};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TableDescriptor';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{isEnabled});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{analyzerDefinition} = new Blur::AnalyzerDefinition();
        $xfer += $self->{analyzerDefinition}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{shardCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableUri});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{compressionClass});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{compressionBlockSize});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cluster});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{similarityClass});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{blockCaching});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::SET) {
        {
          my $_size140 = 0;
          $self->{blockCachingFileTypes} = {};
          my $_etype143 = 0;
          $xfer += $input->readSetBegin(\$_etype143, \$_size140);
          for (my $_i144 = 0; $_i144 < $_size140; ++$_i144)
          {
            my $elem145 = undef;
            $xfer += $input->readString(\$elem145);
            $self->{blockCachingFileTypes}->{$elem145} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{readOnly});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{columnPreCache} = new Blur::ColumnPreCache();
        $xfer += $self->{columnPreCache}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size146 = 0;
          $self->{tableProperties} = {};
          my $_ktype147 = 0;
          my $_vtype148 = 0;
          $xfer += $input->readMapBegin(\$_ktype147, \$_vtype148, \$_size146);
          for (my $_i150 = 0; $_i150 < $_size146; ++$_i150)
          {
            my $key151 = '';
            my $val152 = '';
            $xfer += $input->readString(\$key151);
            $xfer += $input->readString(\$val152);
            $self->{tableProperties}->{$key151} = $val152;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TableDescriptor');
  if (defined $self->{isEnabled}) {
    $xfer += $output->writeFieldBegin('isEnabled', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{isEnabled});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{analyzerDefinition}) {
    $xfer += $output->writeFieldBegin('analyzerDefinition', TType::STRUCT, 2);
    $xfer += $self->{analyzerDefinition}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{shardCount}) {
    $xfer += $output->writeFieldBegin('shardCount', TType::I32, 3);
    $xfer += $output->writeI32($self->{shardCount});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tableUri}) {
    $xfer += $output->writeFieldBegin('tableUri', TType::STRING, 4);
    $xfer += $output->writeString($self->{tableUri});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compressionClass}) {
    $xfer += $output->writeFieldBegin('compressionClass', TType::STRING, 5);
    $xfer += $output->writeString($self->{compressionClass});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compressionBlockSize}) {
    $xfer += $output->writeFieldBegin('compressionBlockSize', TType::I32, 6);
    $xfer += $output->writeI32($self->{compressionBlockSize});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cluster}) {
    $xfer += $output->writeFieldBegin('cluster', TType::STRING, 7);
    $xfer += $output->writeString($self->{cluster});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 8);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{similarityClass}) {
    $xfer += $output->writeFieldBegin('similarityClass', TType::STRING, 9);
    $xfer += $output->writeString($self->{similarityClass});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{blockCaching}) {
    $xfer += $output->writeFieldBegin('blockCaching', TType::BOOL, 10);
    $xfer += $output->writeBool($self->{blockCaching});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{blockCachingFileTypes}) {
    $xfer += $output->writeFieldBegin('blockCachingFileTypes', TType::SET, 11);
    {
      $xfer += $output->writeSetBegin(TType::STRING, scalar(@{$self->{blockCachingFileTypes}}));
      {
        foreach my $iter153 (@{$self->{blockCachingFileTypes}})
        {
          $xfer += $output->writeString($iter153);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{readOnly}) {
    $xfer += $output->writeFieldBegin('readOnly', TType::BOOL, 12);
    $xfer += $output->writeBool($self->{readOnly});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnPreCache}) {
    $xfer += $output->writeFieldBegin('columnPreCache', TType::STRUCT, 13);
    $xfer += $self->{columnPreCache}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tableProperties}) {
    $xfer += $output->writeFieldBegin('tableProperties', TType::MAP, 14);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{tableProperties}}));
      {
        while( my ($kiter154,$viter155) = each %{$self->{tableProperties}}) 
        {
          $xfer += $output->writeString($kiter154);
          $xfer += $output->writeString($viter155);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;
