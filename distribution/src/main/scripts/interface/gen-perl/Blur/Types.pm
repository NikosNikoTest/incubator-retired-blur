#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

package Blur::ErrorType;
use constant UNKNOWN => 0;
use constant QUERY_CANCEL => 1;
use constant QUERY_TIMEOUT => 2;
use constant BACK_PRESSURE => 3;
use constant REQUEST_TIMEOUT => 4;
package Blur::ScoreType;
use constant SUPER => 0;
use constant AGGREGATE => 1;
use constant BEST => 2;
use constant CONSTANT => 3;
package Blur::QueryState;
use constant RUNNING => 0;
use constant INTERRUPTED => 1;
use constant COMPLETE => 2;
use constant BACK_PRESSURE_INTERRUPTED => 3;
package Blur::Status;
use constant NOT_FOUND => 0;
use constant FOUND => 1;
package Blur::RowMutationType;
use constant DELETE_ROW => 0;
use constant REPLACE_ROW => 1;
use constant UPDATE_ROW => 2;
package Blur::RecordMutationType;
use constant DELETE_ENTIRE_RECORD => 0;
use constant REPLACE_ENTIRE_RECORD => 1;
use constant REPLACE_COLUMNS => 2;
use constant APPEND_COLUMN_VALUES => 3;
package Blur::ShardState;
use constant OPENING => 0;
use constant OPEN => 1;
use constant OPENING_ERROR => 2;
use constant CLOSING => 3;
use constant CLOSED => 4;
use constant CLOSING_ERROR => 5;
package Blur::BlurException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Blur::BlurException->mk_accessors( qw( message stackTraceStr errorType ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  $self->{stackTraceStr} = undef;
  $self->{errorType} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
    if (defined $vals->{stackTraceStr}) {
      $self->{stackTraceStr} = $vals->{stackTraceStr};
    }
    if (defined $vals->{errorType}) {
      $self->{errorType} = $vals->{errorType};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{stackTraceStr});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{errorType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stackTraceStr}) {
    $xfer += $output->writeFieldBegin('stackTraceStr', TType::STRING, 2);
    $xfer += $output->writeString($self->{stackTraceStr});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{errorType}) {
    $xfer += $output->writeFieldBegin('errorType', TType::I32, 3);
    $xfer += $output->writeI32($self->{errorType});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Column;
use base qw(Class::Accessor);
Blur::Column->mk_accessors( qw( name value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Column';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Column');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 2);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Record;
use base qw(Class::Accessor);
Blur::Record->mk_accessors( qw( recordId family columns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{recordId} = undef;
  $self->{family} = undef;
  $self->{columns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{recordId}) {
      $self->{recordId} = $vals->{recordId};
    }
    if (defined $vals->{family}) {
      $self->{family} = $vals->{family};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Record';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{recordId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size0 = 0;
          $self->{columns} = [];
          my $_etype3 = 0;
          $xfer += $input->readListBegin(\$_etype3, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $elem5 = undef;
            $elem5 = new Blur::Column();
            $xfer += $elem5->read($input);
            push(@{$self->{columns}},$elem5);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Record');
  if (defined $self->{recordId}) {
    $xfer += $output->writeFieldBegin('recordId', TType::STRING, 1);
    $xfer += $output->writeString($self->{recordId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{family}) {
    $xfer += $output->writeFieldBegin('family', TType::STRING, 2);
    $xfer += $output->writeString($self->{family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter6 (@{$self->{columns}}) 
        {
          $xfer += ${iter6}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Row;
use base qw(Class::Accessor);
Blur::Row->mk_accessors( qw( id records recordCount ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{id} = undef;
  $self->{records} = undef;
  $self->{recordCount} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{records}) {
      $self->{records} = $vals->{records};
    }
    if (defined $vals->{recordCount}) {
      $self->{recordCount} = $vals->{recordCount};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Row';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size7 = 0;
          $self->{records} = [];
          my $_etype10 = 0;
          $xfer += $input->readListBegin(\$_etype10, \$_size7);
          for (my $_i11 = 0; $_i11 < $_size7; ++$_i11)
          {
            my $elem12 = undef;
            $elem12 = new Blur::Record();
            $xfer += $elem12->read($input);
            push(@{$self->{records}},$elem12);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{recordCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Row');
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
    $xfer += $output->writeString($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{records}) {
    $xfer += $output->writeFieldBegin('records', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{records}}));
      {
        foreach my $iter13 (@{$self->{records}}) 
        {
          $xfer += ${iter13}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordCount}) {
    $xfer += $output->writeFieldBegin('recordCount', TType::I32, 3);
    $xfer += $output->writeI32($self->{recordCount});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::SimpleQuery;
use base qw(Class::Accessor);
Blur::SimpleQuery->mk_accessors( qw( queryStr superQueryOn type postSuperFilter preSuperFilter ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{queryStr} = undef;
  $self->{superQueryOn} = 1;
  $self->{type} = 0;
  $self->{postSuperFilter} = undef;
  $self->{preSuperFilter} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{queryStr}) {
      $self->{queryStr} = $vals->{queryStr};
    }
    if (defined $vals->{superQueryOn}) {
      $self->{superQueryOn} = $vals->{superQueryOn};
    }
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
    if (defined $vals->{postSuperFilter}) {
      $self->{postSuperFilter} = $vals->{postSuperFilter};
    }
    if (defined $vals->{preSuperFilter}) {
      $self->{preSuperFilter} = $vals->{preSuperFilter};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SimpleQuery';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{queryStr});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{superQueryOn});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{postSuperFilter});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{preSuperFilter});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SimpleQuery');
  if (defined $self->{queryStr}) {
    $xfer += $output->writeFieldBegin('queryStr', TType::STRING, 1);
    $xfer += $output->writeString($self->{queryStr});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{superQueryOn}) {
    $xfer += $output->writeFieldBegin('superQueryOn', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{superQueryOn});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::I32, 3);
    $xfer += $output->writeI32($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{postSuperFilter}) {
    $xfer += $output->writeFieldBegin('postSuperFilter', TType::STRING, 4);
    $xfer += $output->writeString($self->{postSuperFilter});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{preSuperFilter}) {
    $xfer += $output->writeFieldBegin('preSuperFilter', TType::STRING, 5);
    $xfer += $output->writeString($self->{preSuperFilter});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::HighlightOptions;
use base qw(Class::Accessor);
Blur::HighlightOptions->mk_accessors( qw( simpleQuery preTag postTag ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{simpleQuery} = undef;
  $self->{preTag} = "<<<";
  $self->{postTag} = ">>>";
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{simpleQuery}) {
      $self->{simpleQuery} = $vals->{simpleQuery};
    }
    if (defined $vals->{preTag}) {
      $self->{preTag} = $vals->{preTag};
    }
    if (defined $vals->{postTag}) {
      $self->{postTag} = $vals->{postTag};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'HighlightOptions';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{simpleQuery} = new Blur::SimpleQuery();
        $xfer += $self->{simpleQuery}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{preTag});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{postTag});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('HighlightOptions');
  if (defined $self->{simpleQuery}) {
    $xfer += $output->writeFieldBegin('simpleQuery', TType::STRUCT, 1);
    $xfer += $self->{simpleQuery}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{preTag}) {
    $xfer += $output->writeFieldBegin('preTag', TType::STRING, 2);
    $xfer += $output->writeString($self->{preTag});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{postTag}) {
    $xfer += $output->writeFieldBegin('postTag', TType::STRING, 3);
    $xfer += $output->writeString($self->{postTag});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Selector;
use base qw(Class::Accessor);
Blur::Selector->mk_accessors( qw( recordOnly locationId rowId recordId columnFamiliesToFetch columnsToFetch allowStaleData startRecord maxRecordsToFetch highlightOptions ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{recordOnly} = undef;
  $self->{locationId} = undef;
  $self->{rowId} = undef;
  $self->{recordId} = undef;
  $self->{columnFamiliesToFetch} = undef;
  $self->{columnsToFetch} = undef;
  $self->{allowStaleData} = undef;
  $self->{startRecord} = 0;
  $self->{maxRecordsToFetch} = 1000;
  $self->{highlightOptions} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{recordOnly}) {
      $self->{recordOnly} = $vals->{recordOnly};
    }
    if (defined $vals->{locationId}) {
      $self->{locationId} = $vals->{locationId};
    }
    if (defined $vals->{rowId}) {
      $self->{rowId} = $vals->{rowId};
    }
    if (defined $vals->{recordId}) {
      $self->{recordId} = $vals->{recordId};
    }
    if (defined $vals->{columnFamiliesToFetch}) {
      $self->{columnFamiliesToFetch} = $vals->{columnFamiliesToFetch};
    }
    if (defined $vals->{columnsToFetch}) {
      $self->{columnsToFetch} = $vals->{columnsToFetch};
    }
    if (defined $vals->{allowStaleData}) {
      $self->{allowStaleData} = $vals->{allowStaleData};
    }
    if (defined $vals->{startRecord}) {
      $self->{startRecord} = $vals->{startRecord};
    }
    if (defined $vals->{maxRecordsToFetch}) {
      $self->{maxRecordsToFetch} = $vals->{maxRecordsToFetch};
    }
    if (defined $vals->{highlightOptions}) {
      $self->{highlightOptions} = $vals->{highlightOptions};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Selector';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{recordOnly});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{locationId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{rowId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{recordId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size14 = 0;
          $self->{columnFamiliesToFetch} = [];
          my $_etype17 = 0;
          $xfer += $input->readListBegin(\$_etype17, \$_size14);
          for (my $_i18 = 0; $_i18 < $_size14; ++$_i18)
          {
            my $elem19 = undef;
            $xfer += $input->readString(\$elem19);
            push(@{$self->{columnFamiliesToFetch}},$elem19);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size20 = 0;
          $self->{columnsToFetch} = {};
          my $_ktype21 = 0;
          my $_vtype22 = 0;
          $xfer += $input->readMapBegin(\$_ktype21, \$_vtype22, \$_size20);
          for (my $_i24 = 0; $_i24 < $_size20; ++$_i24)
          {
            my $key25 = '';
            my $val26 = [];
            $xfer += $input->readString(\$key25);
            {
              my $_size27 = 0;
              $val26 = {};
              my $_etype30 = 0;
              $xfer += $input->readSetBegin(\$_etype30, \$_size27);
              for (my $_i31 = 0; $_i31 < $_size27; ++$_i31)
              {
                my $elem32 = undef;
                $xfer += $input->readString(\$elem32);
                $val26->{$elem32} = 1;
              }
              $xfer += $input->readSetEnd();
            }
            $self->{columnsToFetch}->{$key25} = $val26;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{allowStaleData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{startRecord});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{maxRecordsToFetch});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{highlightOptions} = new Blur::HighlightOptions();
        $xfer += $self->{highlightOptions}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Selector');
  if (defined $self->{recordOnly}) {
    $xfer += $output->writeFieldBegin('recordOnly', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{recordOnly});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{locationId}) {
    $xfer += $output->writeFieldBegin('locationId', TType::STRING, 2);
    $xfer += $output->writeString($self->{locationId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowId}) {
    $xfer += $output->writeFieldBegin('rowId', TType::STRING, 3);
    $xfer += $output->writeString($self->{rowId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordId}) {
    $xfer += $output->writeFieldBegin('recordId', TType::STRING, 4);
    $xfer += $output->writeString($self->{recordId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamiliesToFetch}) {
    $xfer += $output->writeFieldBegin('columnFamiliesToFetch', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{columnFamiliesToFetch}}));
      {
        foreach my $iter33 (@{$self->{columnFamiliesToFetch}}) 
        {
          $xfer += $output->writeString($iter33);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnsToFetch}) {
    $xfer += $output->writeFieldBegin('columnsToFetch', TType::MAP, 6);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::SET, scalar(keys %{$self->{columnsToFetch}}));
      {
        while( my ($kiter34,$viter35) = each %{$self->{columnsToFetch}}) 
        {
          $xfer += $output->writeString($kiter34);
          {
            $xfer += $output->writeSetBegin(TType::STRING, scalar(@{${viter35}}));
            {
              foreach my $iter36 (@{${viter35}})
              {
                $xfer += $output->writeString($iter36);
              }
            }
            $xfer += $output->writeSetEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{allowStaleData}) {
    $xfer += $output->writeFieldBegin('allowStaleData', TType::BOOL, 7);
    $xfer += $output->writeBool($self->{allowStaleData});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startRecord}) {
    $xfer += $output->writeFieldBegin('startRecord', TType::I32, 8);
    $xfer += $output->writeI32($self->{startRecord});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{maxRecordsToFetch}) {
    $xfer += $output->writeFieldBegin('maxRecordsToFetch', TType::I32, 9);
    $xfer += $output->writeI32($self->{maxRecordsToFetch});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{highlightOptions}) {
    $xfer += $output->writeFieldBegin('highlightOptions', TType::STRUCT, 10);
    $xfer += $self->{highlightOptions}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::FetchRowResult;
use base qw(Class::Accessor);
Blur::FetchRowResult->mk_accessors( qw( row ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{row} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'FetchRowResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{row} = new Blur::Row();
        $xfer += $self->{row}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('FetchRowResult');
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRUCT, 1);
    $xfer += $self->{row}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::FetchRecordResult;
use base qw(Class::Accessor);
Blur::FetchRecordResult->mk_accessors( qw( rowid record ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{rowid} = undef;
  $self->{record} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{rowid}) {
      $self->{rowid} = $vals->{rowid};
    }
    if (defined $vals->{record}) {
      $self->{record} = $vals->{record};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'FetchRecordResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{rowid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{record} = new Blur::Record();
        $xfer += $self->{record}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('FetchRecordResult');
  if (defined $self->{rowid}) {
    $xfer += $output->writeFieldBegin('rowid', TType::STRING, 1);
    $xfer += $output->writeString($self->{rowid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{record}) {
    $xfer += $output->writeFieldBegin('record', TType::STRUCT, 2);
    $xfer += $self->{record}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::FetchResult;
use base qw(Class::Accessor);
Blur::FetchResult->mk_accessors( qw( exists deleted table rowResult recordResult ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{exists} = undef;
  $self->{deleted} = undef;
  $self->{table} = undef;
  $self->{rowResult} = undef;
  $self->{recordResult} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{exists}) {
      $self->{exists} = $vals->{exists};
    }
    if (defined $vals->{deleted}) {
      $self->{deleted} = $vals->{deleted};
    }
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{rowResult}) {
      $self->{rowResult} = $vals->{rowResult};
    }
    if (defined $vals->{recordResult}) {
      $self->{recordResult} = $vals->{recordResult};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'FetchResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{exists});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleted});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{rowResult} = new Blur::FetchRowResult();
        $xfer += $self->{rowResult}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{recordResult} = new Blur::FetchRecordResult();
        $xfer += $self->{recordResult}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('FetchResult');
  if (defined $self->{exists}) {
    $xfer += $output->writeFieldBegin('exists', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{exists});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleted}) {
    $xfer += $output->writeFieldBegin('deleted', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{deleted});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 3);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowResult}) {
    $xfer += $output->writeFieldBegin('rowResult', TType::STRUCT, 4);
    $xfer += $self->{rowResult}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordResult}) {
    $xfer += $output->writeFieldBegin('recordResult', TType::STRUCT, 5);
    $xfer += $self->{recordResult}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Facet;
use base qw(Class::Accessor);
Blur::Facet->mk_accessors( qw( queryStr minimumNumberOfBlurResults ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{queryStr} = undef;
  $self->{minimumNumberOfBlurResults} = 9223372036854775807;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{queryStr}) {
      $self->{queryStr} = $vals->{queryStr};
    }
    if (defined $vals->{minimumNumberOfBlurResults}) {
      $self->{minimumNumberOfBlurResults} = $vals->{minimumNumberOfBlurResults};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Facet';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{queryStr});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{minimumNumberOfBlurResults});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Facet');
  if (defined $self->{queryStr}) {
    $xfer += $output->writeFieldBegin('queryStr', TType::STRING, 1);
    $xfer += $output->writeString($self->{queryStr});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{minimumNumberOfBlurResults}) {
    $xfer += $output->writeFieldBegin('minimumNumberOfBlurResults', TType::I64, 2);
    $xfer += $output->writeI64($self->{minimumNumberOfBlurResults});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurQuery;
use base qw(Class::Accessor);
Blur::BlurQuery->mk_accessors( qw( simpleQuery facets selector useCacheIfPresent start fetch minimumNumberOfResults maxQueryTime uuid userContext cacheResult startTime ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{simpleQuery} = undef;
  $self->{facets} = undef;
  $self->{selector} = undef;
  $self->{useCacheIfPresent} = 1;
  $self->{start} = 0;
  $self->{fetch} = 10;
  $self->{minimumNumberOfResults} = 9223372036854775807;
  $self->{maxQueryTime} = 9223372036854775807;
  $self->{uuid} = undef;
  $self->{userContext} = undef;
  $self->{cacheResult} = 1;
  $self->{startTime} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{simpleQuery}) {
      $self->{simpleQuery} = $vals->{simpleQuery};
    }
    if (defined $vals->{facets}) {
      $self->{facets} = $vals->{facets};
    }
    if (defined $vals->{selector}) {
      $self->{selector} = $vals->{selector};
    }
    if (defined $vals->{useCacheIfPresent}) {
      $self->{useCacheIfPresent} = $vals->{useCacheIfPresent};
    }
    if (defined $vals->{start}) {
      $self->{start} = $vals->{start};
    }
    if (defined $vals->{fetch}) {
      $self->{fetch} = $vals->{fetch};
    }
    if (defined $vals->{minimumNumberOfResults}) {
      $self->{minimumNumberOfResults} = $vals->{minimumNumberOfResults};
    }
    if (defined $vals->{maxQueryTime}) {
      $self->{maxQueryTime} = $vals->{maxQueryTime};
    }
    if (defined $vals->{uuid}) {
      $self->{uuid} = $vals->{uuid};
    }
    if (defined $vals->{userContext}) {
      $self->{userContext} = $vals->{userContext};
    }
    if (defined $vals->{cacheResult}) {
      $self->{cacheResult} = $vals->{cacheResult};
    }
    if (defined $vals->{startTime}) {
      $self->{startTime} = $vals->{startTime};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurQuery';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{simpleQuery} = new Blur::SimpleQuery();
        $xfer += $self->{simpleQuery}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size37 = 0;
          $self->{facets} = [];
          my $_etype40 = 0;
          $xfer += $input->readListBegin(\$_etype40, \$_size37);
          for (my $_i41 = 0; $_i41 < $_size37; ++$_i41)
          {
            my $elem42 = undef;
            $elem42 = new Blur::Facet();
            $xfer += $elem42->read($input);
            push(@{$self->{facets}},$elem42);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{selector} = new Blur::Selector();
        $xfer += $self->{selector}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{useCacheIfPresent});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{start});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{fetch});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{minimumNumberOfResults});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{maxQueryTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{uuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{userContext});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{cacheResult});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{startTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurQuery');
  if (defined $self->{simpleQuery}) {
    $xfer += $output->writeFieldBegin('simpleQuery', TType::STRUCT, 1);
    $xfer += $self->{simpleQuery}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{facets}) {
    $xfer += $output->writeFieldBegin('facets', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{facets}}));
      {
        foreach my $iter43 (@{$self->{facets}}) 
        {
          $xfer += ${iter43}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{selector}) {
    $xfer += $output->writeFieldBegin('selector', TType::STRUCT, 4);
    $xfer += $self->{selector}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{useCacheIfPresent}) {
    $xfer += $output->writeFieldBegin('useCacheIfPresent', TType::BOOL, 6);
    $xfer += $output->writeBool($self->{useCacheIfPresent});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start}) {
    $xfer += $output->writeFieldBegin('start', TType::I64, 7);
    $xfer += $output->writeI64($self->{start});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fetch}) {
    $xfer += $output->writeFieldBegin('fetch', TType::I32, 8);
    $xfer += $output->writeI32($self->{fetch});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{minimumNumberOfResults}) {
    $xfer += $output->writeFieldBegin('minimumNumberOfResults', TType::I64, 9);
    $xfer += $output->writeI64($self->{minimumNumberOfResults});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{maxQueryTime}) {
    $xfer += $output->writeFieldBegin('maxQueryTime', TType::I64, 10);
    $xfer += $output->writeI64($self->{maxQueryTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uuid}) {
    $xfer += $output->writeFieldBegin('uuid', TType::I64, 11);
    $xfer += $output->writeI64($self->{uuid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userContext}) {
    $xfer += $output->writeFieldBegin('userContext', TType::STRING, 12);
    $xfer += $output->writeString($self->{userContext});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cacheResult}) {
    $xfer += $output->writeFieldBegin('cacheResult', TType::BOOL, 13);
    $xfer += $output->writeBool($self->{cacheResult});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startTime}) {
    $xfer += $output->writeFieldBegin('startTime', TType::I64, 14);
    $xfer += $output->writeI64($self->{startTime});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurResult;
use base qw(Class::Accessor);
Blur::BlurResult->mk_accessors( qw( locationId score fetchResult ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{locationId} = undef;
  $self->{score} = undef;
  $self->{fetchResult} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{locationId}) {
      $self->{locationId} = $vals->{locationId};
    }
    if (defined $vals->{score}) {
      $self->{score} = $vals->{score};
    }
    if (defined $vals->{fetchResult}) {
      $self->{fetchResult} = $vals->{fetchResult};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{locationId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{score});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{fetchResult} = new Blur::FetchResult();
        $xfer += $self->{fetchResult}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurResult');
  if (defined $self->{locationId}) {
    $xfer += $output->writeFieldBegin('locationId', TType::STRING, 1);
    $xfer += $output->writeString($self->{locationId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{score}) {
    $xfer += $output->writeFieldBegin('score', TType::DOUBLE, 2);
    $xfer += $output->writeDouble($self->{score});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fetchResult}) {
    $xfer += $output->writeFieldBegin('fetchResult', TType::STRUCT, 3);
    $xfer += $self->{fetchResult}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurResults;
use base qw(Class::Accessor);
Blur::BlurResults->mk_accessors( qw( totalResults shardInfo results facetCounts exceptions query ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{totalResults} = 0;
  $self->{shardInfo} = undef;
  $self->{results} = undef;
  $self->{facetCounts} = undef;
  $self->{exceptions} = undef;
  $self->{query} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{totalResults}) {
      $self->{totalResults} = $vals->{totalResults};
    }
    if (defined $vals->{shardInfo}) {
      $self->{shardInfo} = $vals->{shardInfo};
    }
    if (defined $vals->{results}) {
      $self->{results} = $vals->{results};
    }
    if (defined $vals->{facetCounts}) {
      $self->{facetCounts} = $vals->{facetCounts};
    }
    if (defined $vals->{exceptions}) {
      $self->{exceptions} = $vals->{exceptions};
    }
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurResults';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{totalResults});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size44 = 0;
          $self->{shardInfo} = {};
          my $_ktype45 = 0;
          my $_vtype46 = 0;
          $xfer += $input->readMapBegin(\$_ktype45, \$_vtype46, \$_size44);
          for (my $_i48 = 0; $_i48 < $_size44; ++$_i48)
          {
            my $key49 = '';
            my $val50 = 0;
            $xfer += $input->readString(\$key49);
            $xfer += $input->readI64(\$val50);
            $self->{shardInfo}->{$key49} = $val50;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size51 = 0;
          $self->{results} = [];
          my $_etype54 = 0;
          $xfer += $input->readListBegin(\$_etype54, \$_size51);
          for (my $_i55 = 0; $_i55 < $_size51; ++$_i55)
          {
            my $elem56 = undef;
            $elem56 = new Blur::BlurResult();
            $xfer += $elem56->read($input);
            push(@{$self->{results}},$elem56);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size57 = 0;
          $self->{facetCounts} = [];
          my $_etype60 = 0;
          $xfer += $input->readListBegin(\$_etype60, \$_size57);
          for (my $_i61 = 0; $_i61 < $_size57; ++$_i61)
          {
            my $elem62 = undef;
            $xfer += $input->readI64(\$elem62);
            push(@{$self->{facetCounts}},$elem62);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size63 = 0;
          $self->{exceptions} = [];
          my $_etype66 = 0;
          $xfer += $input->readListBegin(\$_etype66, \$_size63);
          for (my $_i67 = 0; $_i67 < $_size63; ++$_i67)
          {
            my $elem68 = undef;
            $elem68 = new Blur::BlurException();
            $xfer += $elem68->read($input);
            push(@{$self->{exceptions}},$elem68);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{query} = new Blur::BlurQuery();
        $xfer += $self->{query}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurResults');
  if (defined $self->{totalResults}) {
    $xfer += $output->writeFieldBegin('totalResults', TType::I64, 1);
    $xfer += $output->writeI64($self->{totalResults});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{shardInfo}) {
    $xfer += $output->writeFieldBegin('shardInfo', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::I64, scalar(keys %{$self->{shardInfo}}));
      {
        while( my ($kiter69,$viter70) = each %{$self->{shardInfo}}) 
        {
          $xfer += $output->writeString($kiter69);
          $xfer += $output->writeI64($viter70);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{results}) {
    $xfer += $output->writeFieldBegin('results', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{results}}));
      {
        foreach my $iter71 (@{$self->{results}}) 
        {
          $xfer += ${iter71}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{facetCounts}) {
    $xfer += $output->writeFieldBegin('facetCounts', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::I64, scalar(@{$self->{facetCounts}}));
      {
        foreach my $iter72 (@{$self->{facetCounts}}) 
        {
          $xfer += $output->writeI64($iter72);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{exceptions}) {
    $xfer += $output->writeFieldBegin('exceptions', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{exceptions}}));
      {
        foreach my $iter73 (@{$self->{exceptions}}) 
        {
          $xfer += ${iter73}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRUCT, 6);
    $xfer += $self->{query}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::RecordMutation;
use base qw(Class::Accessor);
Blur::RecordMutation->mk_accessors( qw( recordMutationType record ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{recordMutationType} = undef;
  $self->{record} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{recordMutationType}) {
      $self->{recordMutationType} = $vals->{recordMutationType};
    }
    if (defined $vals->{record}) {
      $self->{record} = $vals->{record};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecordMutation';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{recordMutationType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{record} = new Blur::Record();
        $xfer += $self->{record}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecordMutation');
  if (defined $self->{recordMutationType}) {
    $xfer += $output->writeFieldBegin('recordMutationType', TType::I32, 1);
    $xfer += $output->writeI32($self->{recordMutationType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{record}) {
    $xfer += $output->writeFieldBegin('record', TType::STRUCT, 2);
    $xfer += $self->{record}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::RowMutation;
use base qw(Class::Accessor);
Blur::RowMutation->mk_accessors( qw( table rowId wal rowMutationType recordMutations waitToBeVisible ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{rowId} = undef;
  $self->{wal} = 1;
  $self->{rowMutationType} = undef;
  $self->{recordMutations} = undef;
  $self->{waitToBeVisible} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{rowId}) {
      $self->{rowId} = $vals->{rowId};
    }
    if (defined $vals->{wal}) {
      $self->{wal} = $vals->{wal};
    }
    if (defined $vals->{rowMutationType}) {
      $self->{rowMutationType} = $vals->{rowMutationType};
    }
    if (defined $vals->{recordMutations}) {
      $self->{recordMutations} = $vals->{recordMutations};
    }
    if (defined $vals->{waitToBeVisible}) {
      $self->{waitToBeVisible} = $vals->{waitToBeVisible};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RowMutation';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{rowId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{wal});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{rowMutationType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size74 = 0;
          $self->{recordMutations} = [];
          my $_etype77 = 0;
          $xfer += $input->readListBegin(\$_etype77, \$_size74);
          for (my $_i78 = 0; $_i78 < $_size74; ++$_i78)
          {
            my $elem79 = undef;
            $elem79 = new Blur::RecordMutation();
            $xfer += $elem79->read($input);
            push(@{$self->{recordMutations}},$elem79);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{waitToBeVisible});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RowMutation');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowId}) {
    $xfer += $output->writeFieldBegin('rowId', TType::STRING, 2);
    $xfer += $output->writeString($self->{rowId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{wal}) {
    $xfer += $output->writeFieldBegin('wal', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{wal});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowMutationType}) {
    $xfer += $output->writeFieldBegin('rowMutationType', TType::I32, 4);
    $xfer += $output->writeI32($self->{rowMutationType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordMutations}) {
    $xfer += $output->writeFieldBegin('recordMutations', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{recordMutations}}));
      {
        foreach my $iter80 (@{$self->{recordMutations}}) 
        {
          $xfer += ${iter80}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{waitToBeVisible}) {
    $xfer += $output->writeFieldBegin('waitToBeVisible', TType::BOOL, 6);
    $xfer += $output->writeBool($self->{waitToBeVisible});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::CpuTime;
use base qw(Class::Accessor);
Blur::CpuTime->mk_accessors( qw( cpuTime realTime ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cpuTime} = undef;
  $self->{realTime} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cpuTime}) {
      $self->{cpuTime} = $vals->{cpuTime};
    }
    if (defined $vals->{realTime}) {
      $self->{realTime} = $vals->{realTime};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CpuTime';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{cpuTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{realTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CpuTime');
  if (defined $self->{cpuTime}) {
    $xfer += $output->writeFieldBegin('cpuTime', TType::I64, 1);
    $xfer += $output->writeI64($self->{cpuTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{realTime}) {
    $xfer += $output->writeFieldBegin('realTime', TType::I64, 2);
    $xfer += $output->writeI64($self->{realTime});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurQueryStatus;
use base qw(Class::Accessor);
Blur::BlurQueryStatus->mk_accessors( qw( query cpuTimes completeShards totalShards state uuid status ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{query} = undef;
  $self->{cpuTimes} = undef;
  $self->{completeShards} = undef;
  $self->{totalShards} = undef;
  $self->{state} = undef;
  $self->{uuid} = undef;
  $self->{status} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{cpuTimes}) {
      $self->{cpuTimes} = $vals->{cpuTimes};
    }
    if (defined $vals->{completeShards}) {
      $self->{completeShards} = $vals->{completeShards};
    }
    if (defined $vals->{totalShards}) {
      $self->{totalShards} = $vals->{totalShards};
    }
    if (defined $vals->{state}) {
      $self->{state} = $vals->{state};
    }
    if (defined $vals->{uuid}) {
      $self->{uuid} = $vals->{uuid};
    }
    if (defined $vals->{status}) {
      $self->{status} = $vals->{status};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurQueryStatus';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{query} = new Blur::BlurQuery();
        $xfer += $self->{query}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size81 = 0;
          $self->{cpuTimes} = {};
          my $_ktype82 = 0;
          my $_vtype83 = 0;
          $xfer += $input->readMapBegin(\$_ktype82, \$_vtype83, \$_size81);
          for (my $_i85 = 0; $_i85 < $_size81; ++$_i85)
          {
            my $key86 = '';
            my $val87 = new Blur::CpuTime();
            $xfer += $input->readString(\$key86);
            $val87 = new Blur::CpuTime();
            $xfer += $val87->read($input);
            $self->{cpuTimes}->{$key86} = $val87;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{completeShards});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{totalShards});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{state});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{uuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{status});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurQueryStatus');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRUCT, 1);
    $xfer += $self->{query}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cpuTimes}) {
    $xfer += $output->writeFieldBegin('cpuTimes', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{cpuTimes}}));
      {
        while( my ($kiter88,$viter89) = each %{$self->{cpuTimes}}) 
        {
          $xfer += $output->writeString($kiter88);
          $xfer += ${viter89}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{completeShards}) {
    $xfer += $output->writeFieldBegin('completeShards', TType::I32, 3);
    $xfer += $output->writeI32($self->{completeShards});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{totalShards}) {
    $xfer += $output->writeFieldBegin('totalShards', TType::I32, 4);
    $xfer += $output->writeI32($self->{totalShards});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{state}) {
    $xfer += $output->writeFieldBegin('state', TType::I32, 5);
    $xfer += $output->writeI32($self->{state});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uuid}) {
    $xfer += $output->writeFieldBegin('uuid', TType::I64, 6);
    $xfer += $output->writeI64($self->{uuid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{status}) {
    $xfer += $output->writeFieldBegin('status', TType::I32, 7);
    $xfer += $output->writeI32($self->{status});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::TableStats;
use base qw(Class::Accessor);
Blur::TableStats->mk_accessors( qw( tableName bytes recordCount rowCount queries ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{bytes} = undef;
  $self->{recordCount} = undef;
  $self->{rowCount} = undef;
  $self->{queries} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{bytes}) {
      $self->{bytes} = $vals->{bytes};
    }
    if (defined $vals->{recordCount}) {
      $self->{recordCount} = $vals->{recordCount};
    }
    if (defined $vals->{rowCount}) {
      $self->{rowCount} = $vals->{rowCount};
    }
    if (defined $vals->{queries}) {
      $self->{queries} = $vals->{queries};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TableStats';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{bytes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{recordCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{rowCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{queries});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TableStats');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{bytes}) {
    $xfer += $output->writeFieldBegin('bytes', TType::I64, 2);
    $xfer += $output->writeI64($self->{bytes});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordCount}) {
    $xfer += $output->writeFieldBegin('recordCount', TType::I64, 3);
    $xfer += $output->writeI64($self->{recordCount});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowCount}) {
    $xfer += $output->writeFieldBegin('rowCount', TType::I64, 4);
    $xfer += $output->writeI64($self->{rowCount});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{queries}) {
    $xfer += $output->writeFieldBegin('queries', TType::I64, 5);
    $xfer += $output->writeI64($self->{queries});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Schema;
use base qw(Class::Accessor);
Blur::Schema->mk_accessors( qw( table columnFamilies ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{columnFamilies} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{columnFamilies}) {
      $self->{columnFamilies} = $vals->{columnFamilies};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Schema';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size90 = 0;
          $self->{columnFamilies} = {};
          my $_ktype91 = 0;
          my $_vtype92 = 0;
          $xfer += $input->readMapBegin(\$_ktype91, \$_vtype92, \$_size90);
          for (my $_i94 = 0; $_i94 < $_size90; ++$_i94)
          {
            my $key95 = '';
            my $val96 = [];
            $xfer += $input->readString(\$key95);
            {
              my $_size97 = 0;
              $val96 = {};
              my $_etype100 = 0;
              $xfer += $input->readSetBegin(\$_etype100, \$_size97);
              for (my $_i101 = 0; $_i101 < $_size97; ++$_i101)
              {
                my $elem102 = undef;
                $xfer += $input->readString(\$elem102);
                $val96->{$elem102} = 1;
              }
              $xfer += $input->readSetEnd();
            }
            $self->{columnFamilies}->{$key95} = $val96;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Schema');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamilies}) {
    $xfer += $output->writeFieldBegin('columnFamilies', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::SET, scalar(keys %{$self->{columnFamilies}}));
      {
        while( my ($kiter103,$viter104) = each %{$self->{columnFamilies}}) 
        {
          $xfer += $output->writeString($kiter103);
          {
            $xfer += $output->writeSetBegin(TType::STRING, scalar(@{${viter104}}));
            {
              foreach my $iter105 (@{${viter104}})
              {
                $xfer += $output->writeString($iter105);
              }
            }
            $xfer += $output->writeSetEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::TableDescriptor;
use base qw(Class::Accessor);
Blur::TableDescriptor->mk_accessors( qw( enabled shardCount tableUri cluster name similarityClass blockCaching blockCachingFileTypes readOnly preCacheCols tableProperties strictTypes defaultMissingFieldType defaultMissingFieldLessIndexing defaultMissingFieldProps ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{enabled} = 1;
  $self->{shardCount} = 1;
  $self->{tableUri} = undef;
  $self->{cluster} = "default";
  $self->{name} = undef;
  $self->{similarityClass} = undef;
  $self->{blockCaching} = 1;
  $self->{blockCachingFileTypes} = undef;
  $self->{readOnly} = 0;
  $self->{preCacheCols} = undef;
  $self->{tableProperties} = undef;
  $self->{strictTypes} = 0;
  $self->{defaultMissingFieldType} = "text";
  $self->{defaultMissingFieldLessIndexing} = 1;
  $self->{defaultMissingFieldProps} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{enabled}) {
      $self->{enabled} = $vals->{enabled};
    }
    if (defined $vals->{shardCount}) {
      $self->{shardCount} = $vals->{shardCount};
    }
    if (defined $vals->{tableUri}) {
      $self->{tableUri} = $vals->{tableUri};
    }
    if (defined $vals->{cluster}) {
      $self->{cluster} = $vals->{cluster};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{similarityClass}) {
      $self->{similarityClass} = $vals->{similarityClass};
    }
    if (defined $vals->{blockCaching}) {
      $self->{blockCaching} = $vals->{blockCaching};
    }
    if (defined $vals->{blockCachingFileTypes}) {
      $self->{blockCachingFileTypes} = $vals->{blockCachingFileTypes};
    }
    if (defined $vals->{readOnly}) {
      $self->{readOnly} = $vals->{readOnly};
    }
    if (defined $vals->{preCacheCols}) {
      $self->{preCacheCols} = $vals->{preCacheCols};
    }
    if (defined $vals->{tableProperties}) {
      $self->{tableProperties} = $vals->{tableProperties};
    }
    if (defined $vals->{strictTypes}) {
      $self->{strictTypes} = $vals->{strictTypes};
    }
    if (defined $vals->{defaultMissingFieldType}) {
      $self->{defaultMissingFieldType} = $vals->{defaultMissingFieldType};
    }
    if (defined $vals->{defaultMissingFieldLessIndexing}) {
      $self->{defaultMissingFieldLessIndexing} = $vals->{defaultMissingFieldLessIndexing};
    }
    if (defined $vals->{defaultMissingFieldProps}) {
      $self->{defaultMissingFieldProps} = $vals->{defaultMissingFieldProps};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TableDescriptor';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{enabled});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{shardCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableUri});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cluster});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{similarityClass});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{blockCaching});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::SET) {
        {
          my $_size106 = 0;
          $self->{blockCachingFileTypes} = {};
          my $_etype109 = 0;
          $xfer += $input->readSetBegin(\$_etype109, \$_size106);
          for (my $_i110 = 0; $_i110 < $_size106; ++$_i110)
          {
            my $elem111 = undef;
            $xfer += $input->readString(\$elem111);
            $self->{blockCachingFileTypes}->{$elem111} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{readOnly});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size112 = 0;
          $self->{preCacheCols} = [];
          my $_etype115 = 0;
          $xfer += $input->readListBegin(\$_etype115, \$_size112);
          for (my $_i116 = 0; $_i116 < $_size112; ++$_i116)
          {
            my $elem117 = undef;
            $xfer += $input->readString(\$elem117);
            push(@{$self->{preCacheCols}},$elem117);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size118 = 0;
          $self->{tableProperties} = {};
          my $_ktype119 = 0;
          my $_vtype120 = 0;
          $xfer += $input->readMapBegin(\$_ktype119, \$_vtype120, \$_size118);
          for (my $_i122 = 0; $_i122 < $_size118; ++$_i122)
          {
            my $key123 = '';
            my $val124 = '';
            $xfer += $input->readString(\$key123);
            $xfer += $input->readString(\$val124);
            $self->{tableProperties}->{$key123} = $val124;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^15$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{strictTypes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^16$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{defaultMissingFieldType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^17$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{defaultMissingFieldLessIndexing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^18$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size125 = 0;
          $self->{defaultMissingFieldProps} = {};
          my $_ktype126 = 0;
          my $_vtype127 = 0;
          $xfer += $input->readMapBegin(\$_ktype126, \$_vtype127, \$_size125);
          for (my $_i129 = 0; $_i129 < $_size125; ++$_i129)
          {
            my $key130 = '';
            my $val131 = '';
            $xfer += $input->readString(\$key130);
            $xfer += $input->readString(\$val131);
            $self->{defaultMissingFieldProps}->{$key130} = $val131;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TableDescriptor');
  if (defined $self->{enabled}) {
    $xfer += $output->writeFieldBegin('enabled', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{enabled});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{shardCount}) {
    $xfer += $output->writeFieldBegin('shardCount', TType::I32, 3);
    $xfer += $output->writeI32($self->{shardCount});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tableUri}) {
    $xfer += $output->writeFieldBegin('tableUri', TType::STRING, 4);
    $xfer += $output->writeString($self->{tableUri});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cluster}) {
    $xfer += $output->writeFieldBegin('cluster', TType::STRING, 7);
    $xfer += $output->writeString($self->{cluster});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 8);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{similarityClass}) {
    $xfer += $output->writeFieldBegin('similarityClass', TType::STRING, 9);
    $xfer += $output->writeString($self->{similarityClass});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{blockCaching}) {
    $xfer += $output->writeFieldBegin('blockCaching', TType::BOOL, 10);
    $xfer += $output->writeBool($self->{blockCaching});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{blockCachingFileTypes}) {
    $xfer += $output->writeFieldBegin('blockCachingFileTypes', TType::SET, 11);
    {
      $xfer += $output->writeSetBegin(TType::STRING, scalar(@{$self->{blockCachingFileTypes}}));
      {
        foreach my $iter132 (@{$self->{blockCachingFileTypes}})
        {
          $xfer += $output->writeString($iter132);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{readOnly}) {
    $xfer += $output->writeFieldBegin('readOnly', TType::BOOL, 12);
    $xfer += $output->writeBool($self->{readOnly});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{preCacheCols}) {
    $xfer += $output->writeFieldBegin('preCacheCols', TType::LIST, 13);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{preCacheCols}}));
      {
        foreach my $iter133 (@{$self->{preCacheCols}}) 
        {
          $xfer += $output->writeString($iter133);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tableProperties}) {
    $xfer += $output->writeFieldBegin('tableProperties', TType::MAP, 14);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{tableProperties}}));
      {
        while( my ($kiter134,$viter135) = each %{$self->{tableProperties}}) 
        {
          $xfer += $output->writeString($kiter134);
          $xfer += $output->writeString($viter135);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{strictTypes}) {
    $xfer += $output->writeFieldBegin('strictTypes', TType::BOOL, 15);
    $xfer += $output->writeBool($self->{strictTypes});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{defaultMissingFieldType}) {
    $xfer += $output->writeFieldBegin('defaultMissingFieldType', TType::STRING, 16);
    $xfer += $output->writeString($self->{defaultMissingFieldType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{defaultMissingFieldLessIndexing}) {
    $xfer += $output->writeFieldBegin('defaultMissingFieldLessIndexing', TType::BOOL, 17);
    $xfer += $output->writeBool($self->{defaultMissingFieldLessIndexing});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{defaultMissingFieldProps}) {
    $xfer += $output->writeFieldBegin('defaultMissingFieldProps', TType::MAP, 18);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{defaultMissingFieldProps}}));
      {
        while( my ($kiter136,$viter137) = each %{$self->{defaultMissingFieldProps}}) 
        {
          $xfer += $output->writeString($kiter136);
          $xfer += $output->writeString($viter137);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Metric;
use base qw(Class::Accessor);
Blur::Metric->mk_accessors( qw( name strMap longMap doubleMap ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{strMap} = undef;
  $self->{longMap} = undef;
  $self->{doubleMap} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{strMap}) {
      $self->{strMap} = $vals->{strMap};
    }
    if (defined $vals->{longMap}) {
      $self->{longMap} = $vals->{longMap};
    }
    if (defined $vals->{doubleMap}) {
      $self->{doubleMap} = $vals->{doubleMap};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Metric';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size138 = 0;
          $self->{strMap} = {};
          my $_ktype139 = 0;
          my $_vtype140 = 0;
          $xfer += $input->readMapBegin(\$_ktype139, \$_vtype140, \$_size138);
          for (my $_i142 = 0; $_i142 < $_size138; ++$_i142)
          {
            my $key143 = '';
            my $val144 = '';
            $xfer += $input->readString(\$key143);
            $xfer += $input->readString(\$val144);
            $self->{strMap}->{$key143} = $val144;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size145 = 0;
          $self->{longMap} = {};
          my $_ktype146 = 0;
          my $_vtype147 = 0;
          $xfer += $input->readMapBegin(\$_ktype146, \$_vtype147, \$_size145);
          for (my $_i149 = 0; $_i149 < $_size145; ++$_i149)
          {
            my $key150 = '';
            my $val151 = 0;
            $xfer += $input->readString(\$key150);
            $xfer += $input->readI64(\$val151);
            $self->{longMap}->{$key150} = $val151;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size152 = 0;
          $self->{doubleMap} = {};
          my $_ktype153 = 0;
          my $_vtype154 = 0;
          $xfer += $input->readMapBegin(\$_ktype153, \$_vtype154, \$_size152);
          for (my $_i156 = 0; $_i156 < $_size152; ++$_i156)
          {
            my $key157 = '';
            my $val158 = 0.0;
            $xfer += $input->readString(\$key157);
            $xfer += $input->readDouble(\$val158);
            $self->{doubleMap}->{$key157} = $val158;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Metric');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{strMap}) {
    $xfer += $output->writeFieldBegin('strMap', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{strMap}}));
      {
        while( my ($kiter159,$viter160) = each %{$self->{strMap}}) 
        {
          $xfer += $output->writeString($kiter159);
          $xfer += $output->writeString($viter160);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{longMap}) {
    $xfer += $output->writeFieldBegin('longMap', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::I64, scalar(keys %{$self->{longMap}}));
      {
        while( my ($kiter161,$viter162) = each %{$self->{longMap}}) 
        {
          $xfer += $output->writeString($kiter161);
          $xfer += $output->writeI64($viter162);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{doubleMap}) {
    $xfer += $output->writeFieldBegin('doubleMap', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::DOUBLE, scalar(keys %{$self->{doubleMap}}));
      {
        while( my ($kiter163,$viter164) = each %{$self->{doubleMap}}) 
        {
          $xfer += $output->writeString($kiter163);
          $xfer += $output->writeDouble($viter164);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::ColumnDefinition;
use base qw(Class::Accessor);
Blur::ColumnDefinition->mk_accessors( qw( family columnName subColumnName fieldLessIndexing fieldType properties ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{family} = undef;
  $self->{columnName} = undef;
  $self->{subColumnName} = undef;
  $self->{fieldLessIndexing} = undef;
  $self->{fieldType} = undef;
  $self->{properties} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{family}) {
      $self->{family} = $vals->{family};
    }
    if (defined $vals->{columnName}) {
      $self->{columnName} = $vals->{columnName};
    }
    if (defined $vals->{subColumnName}) {
      $self->{subColumnName} = $vals->{subColumnName};
    }
    if (defined $vals->{fieldLessIndexing}) {
      $self->{fieldLessIndexing} = $vals->{fieldLessIndexing};
    }
    if (defined $vals->{fieldType}) {
      $self->{fieldType} = $vals->{fieldType};
    }
    if (defined $vals->{properties}) {
      $self->{properties} = $vals->{properties};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnDefinition';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{columnName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{subColumnName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{fieldLessIndexing});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{fieldType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size165 = 0;
          $self->{properties} = {};
          my $_ktype166 = 0;
          my $_vtype167 = 0;
          $xfer += $input->readMapBegin(\$_ktype166, \$_vtype167, \$_size165);
          for (my $_i169 = 0; $_i169 < $_size165; ++$_i169)
          {
            my $key170 = '';
            my $val171 = '';
            $xfer += $input->readString(\$key170);
            $xfer += $input->readString(\$val171);
            $self->{properties}->{$key170} = $val171;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnDefinition');
  if (defined $self->{family}) {
    $xfer += $output->writeFieldBegin('family', TType::STRING, 1);
    $xfer += $output->writeString($self->{family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnName}) {
    $xfer += $output->writeFieldBegin('columnName', TType::STRING, 2);
    $xfer += $output->writeString($self->{columnName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{subColumnName}) {
    $xfer += $output->writeFieldBegin('subColumnName', TType::STRING, 3);
    $xfer += $output->writeString($self->{subColumnName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fieldLessIndexing}) {
    $xfer += $output->writeFieldBegin('fieldLessIndexing', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{fieldLessIndexing});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fieldType}) {
    $xfer += $output->writeFieldBegin('fieldType', TType::STRING, 5);
    $xfer += $output->writeString($self->{fieldType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{properties}) {
    $xfer += $output->writeFieldBegin('properties', TType::MAP, 6);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{properties}}));
      {
        while( my ($kiter172,$viter173) = each %{$self->{properties}}) 
        {
          $xfer += $output->writeString($kiter172);
          $xfer += $output->writeString($viter173);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;
