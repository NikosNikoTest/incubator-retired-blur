#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

package Blur::ScoreType;
use constant SUPER => 0;
use constant AGGREGATE => 1;
use constant BEST => 2;
use constant CONSTANT => 3;
package Blur::QueryState;
use constant RUNNING => 0;
use constant INTERRUPTED => 1;
use constant COMPLETE => 2;
package Blur::RowMutationType;
use constant DELETE_ROW => 0;
use constant REPLACE_ROW => 1;
use constant UPDATE_ROW => 2;
package Blur::RecordMutationType;
use constant DELETE_ENTIRE_RECORD => 0;
use constant REPLACE_ENTIRE_RECORD => 1;
use constant REPLACE_COLUMNS => 2;
use constant APPEND_COLUMN_VALUES => 3;
package Blur::ShardState;
use constant OPENING => 0;
use constant OPEN => 1;
use constant OPENING_ERROR => 2;
use constant CLOSING => 3;
use constant CLOSED => 4;
use constant CLOSING_ERROR => 5;
package Blur::BlurException;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Blur::BlurException->mk_accessors( qw( message stackTraceStr ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  $self->{stackTraceStr} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
    if (defined $vals->{stackTraceStr}) {
      $self->{stackTraceStr} = $vals->{stackTraceStr};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurException';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{stackTraceStr});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurException');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stackTraceStr}) {
    $xfer += $output->writeFieldBegin('stackTraceStr', TType::STRING, 2);
    $xfer += $output->writeString($self->{stackTraceStr});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Column;
use base qw(Class::Accessor);
Blur::Column->mk_accessors( qw( name value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Column';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Column');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 2);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Record;
use base qw(Class::Accessor);
Blur::Record->mk_accessors( qw( recordId family columns highlightedColumns ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{recordId} = undef;
  $self->{family} = undef;
  $self->{columns} = undef;
  $self->{highlightedColumns} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{recordId}) {
      $self->{recordId} = $vals->{recordId};
    }
    if (defined $vals->{family}) {
      $self->{family} = $vals->{family};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{highlightedColumns}) {
      $self->{highlightedColumns} = $vals->{highlightedColumns};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Record';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{recordId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size0 = 0;
          $self->{columns} = [];
          my $_etype3 = 0;
          $xfer += $input->readListBegin(\$_etype3, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $elem5 = undef;
            $elem5 = new Blur::Column();
            $xfer += $elem5->read($input);
            push(@{$self->{columns}},$elem5);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size6 = 0;
          $self->{highlightedColumns} = [];
          my $_etype9 = 0;
          $xfer += $input->readListBegin(\$_etype9, \$_size6);
          for (my $_i10 = 0; $_i10 < $_size6; ++$_i10)
          {
            my $elem11 = undef;
            $elem11 = new Blur::Column();
            $xfer += $elem11->read($input);
            push(@{$self->{highlightedColumns}},$elem11);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Record');
  if (defined $self->{recordId}) {
    $xfer += $output->writeFieldBegin('recordId', TType::STRING, 1);
    $xfer += $output->writeString($self->{recordId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{family}) {
    $xfer += $output->writeFieldBegin('family', TType::STRING, 2);
    $xfer += $output->writeString($self->{family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter12 (@{$self->{columns}}) 
        {
          $xfer += ${iter12}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{highlightedColumns}) {
    $xfer += $output->writeFieldBegin('highlightedColumns', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{highlightedColumns}}));
      {
        foreach my $iter13 (@{$self->{highlightedColumns}}) 
        {
          $xfer += ${iter13}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Row;
use base qw(Class::Accessor);
Blur::Row->mk_accessors( qw( id records recordCount ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{id} = undef;
  $self->{records} = undef;
  $self->{recordCount} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{records}) {
      $self->{records} = $vals->{records};
    }
    if (defined $vals->{recordCount}) {
      $self->{recordCount} = $vals->{recordCount};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Row';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size14 = 0;
          $self->{records} = [];
          my $_etype17 = 0;
          $xfer += $input->readListBegin(\$_etype17, \$_size14);
          for (my $_i18 = 0; $_i18 < $_size14; ++$_i18)
          {
            my $elem19 = undef;
            $elem19 = new Blur::Record();
            $xfer += $elem19->read($input);
            push(@{$self->{records}},$elem19);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{recordCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Row');
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::STRING, 1);
    $xfer += $output->writeString($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{records}) {
    $xfer += $output->writeFieldBegin('records', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{records}}));
      {
        foreach my $iter20 (@{$self->{records}}) 
        {
          $xfer += ${iter20}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordCount}) {
    $xfer += $output->writeFieldBegin('recordCount', TType::I32, 3);
    $xfer += $output->writeI32($self->{recordCount});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::SimpleQuery;
use base qw(Class::Accessor);
Blur::SimpleQuery->mk_accessors( qw( queryStr superQueryOn type postSuperFilter preSuperFilter ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{queryStr} = undef;
  $self->{superQueryOn} = 1;
  $self->{type} = 0;
  $self->{postSuperFilter} = undef;
  $self->{preSuperFilter} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{queryStr}) {
      $self->{queryStr} = $vals->{queryStr};
    }
    if (defined $vals->{superQueryOn}) {
      $self->{superQueryOn} = $vals->{superQueryOn};
    }
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
    if (defined $vals->{postSuperFilter}) {
      $self->{postSuperFilter} = $vals->{postSuperFilter};
    }
    if (defined $vals->{preSuperFilter}) {
      $self->{preSuperFilter} = $vals->{preSuperFilter};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'SimpleQuery';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{queryStr});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{superQueryOn});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{postSuperFilter});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{preSuperFilter});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('SimpleQuery');
  if (defined $self->{queryStr}) {
    $xfer += $output->writeFieldBegin('queryStr', TType::STRING, 1);
    $xfer += $output->writeString($self->{queryStr});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{superQueryOn}) {
    $xfer += $output->writeFieldBegin('superQueryOn', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{superQueryOn});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::I32, 3);
    $xfer += $output->writeI32($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{postSuperFilter}) {
    $xfer += $output->writeFieldBegin('postSuperFilter', TType::STRING, 4);
    $xfer += $output->writeString($self->{postSuperFilter});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{preSuperFilter}) {
    $xfer += $output->writeFieldBegin('preSuperFilter', TType::STRING, 5);
    $xfer += $output->writeString($self->{preSuperFilter});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::HighlightOptions;
use base qw(Class::Accessor);
Blur::HighlightOptions->mk_accessors( qw( simpleQuery onlyMatchingRecords ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{simpleQuery} = undef;
  $self->{onlyMatchingRecords} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{simpleQuery}) {
      $self->{simpleQuery} = $vals->{simpleQuery};
    }
    if (defined $vals->{onlyMatchingRecords}) {
      $self->{onlyMatchingRecords} = $vals->{onlyMatchingRecords};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'HighlightOptions';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{simpleQuery} = new Blur::SimpleQuery();
        $xfer += $self->{simpleQuery}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{onlyMatchingRecords});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('HighlightOptions');
  if (defined $self->{simpleQuery}) {
    $xfer += $output->writeFieldBegin('simpleQuery', TType::STRUCT, 1);
    $xfer += $self->{simpleQuery}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{onlyMatchingRecords}) {
    $xfer += $output->writeFieldBegin('onlyMatchingRecords', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{onlyMatchingRecords});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Selector;
use base qw(Class::Accessor);
Blur::Selector->mk_accessors( qw( recordOnly locationId rowId recordId columnFamiliesToFetch columnsToFetch allowStaleData startRecord maxRecordsToFetch highlightOptions ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{recordOnly} = undef;
  $self->{locationId} = undef;
  $self->{rowId} = undef;
  $self->{recordId} = undef;
  $self->{columnFamiliesToFetch} = undef;
  $self->{columnsToFetch} = undef;
  $self->{allowStaleData} = undef;
  $self->{startRecord} = 0;
  $self->{maxRecordsToFetch} = 2147483647;
  $self->{highlightOptions} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{recordOnly}) {
      $self->{recordOnly} = $vals->{recordOnly};
    }
    if (defined $vals->{locationId}) {
      $self->{locationId} = $vals->{locationId};
    }
    if (defined $vals->{rowId}) {
      $self->{rowId} = $vals->{rowId};
    }
    if (defined $vals->{recordId}) {
      $self->{recordId} = $vals->{recordId};
    }
    if (defined $vals->{columnFamiliesToFetch}) {
      $self->{columnFamiliesToFetch} = $vals->{columnFamiliesToFetch};
    }
    if (defined $vals->{columnsToFetch}) {
      $self->{columnsToFetch} = $vals->{columnsToFetch};
    }
    if (defined $vals->{allowStaleData}) {
      $self->{allowStaleData} = $vals->{allowStaleData};
    }
    if (defined $vals->{startRecord}) {
      $self->{startRecord} = $vals->{startRecord};
    }
    if (defined $vals->{maxRecordsToFetch}) {
      $self->{maxRecordsToFetch} = $vals->{maxRecordsToFetch};
    }
    if (defined $vals->{highlightOptions}) {
      $self->{highlightOptions} = $vals->{highlightOptions};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Selector';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{recordOnly});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{locationId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{rowId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{recordId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::SET) {
        {
          my $_size21 = 0;
          $self->{columnFamiliesToFetch} = {};
          my $_etype24 = 0;
          $xfer += $input->readSetBegin(\$_etype24, \$_size21);
          for (my $_i25 = 0; $_i25 < $_size21; ++$_i25)
          {
            my $elem26 = undef;
            $xfer += $input->readString(\$elem26);
            $self->{columnFamiliesToFetch}->{$elem26} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size27 = 0;
          $self->{columnsToFetch} = {};
          my $_ktype28 = 0;
          my $_vtype29 = 0;
          $xfer += $input->readMapBegin(\$_ktype28, \$_vtype29, \$_size27);
          for (my $_i31 = 0; $_i31 < $_size27; ++$_i31)
          {
            my $key32 = '';
            my $val33 = [];
            $xfer += $input->readString(\$key32);
            {
              my $_size34 = 0;
              $val33 = {};
              my $_etype37 = 0;
              $xfer += $input->readSetBegin(\$_etype37, \$_size34);
              for (my $_i38 = 0; $_i38 < $_size34; ++$_i38)
              {
                my $elem39 = undef;
                $xfer += $input->readString(\$elem39);
                $val33->{$elem39} = 1;
              }
              $xfer += $input->readSetEnd();
            }
            $self->{columnsToFetch}->{$key32} = $val33;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{allowStaleData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{startRecord});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{maxRecordsToFetch});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{highlightOptions} = new Blur::HighlightOptions();
        $xfer += $self->{highlightOptions}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Selector');
  if (defined $self->{recordOnly}) {
    $xfer += $output->writeFieldBegin('recordOnly', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{recordOnly});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{locationId}) {
    $xfer += $output->writeFieldBegin('locationId', TType::STRING, 2);
    $xfer += $output->writeString($self->{locationId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowId}) {
    $xfer += $output->writeFieldBegin('rowId', TType::STRING, 3);
    $xfer += $output->writeString($self->{rowId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordId}) {
    $xfer += $output->writeFieldBegin('recordId', TType::STRING, 4);
    $xfer += $output->writeString($self->{recordId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamiliesToFetch}) {
    $xfer += $output->writeFieldBegin('columnFamiliesToFetch', TType::SET, 5);
    {
      $xfer += $output->writeSetBegin(TType::STRING, scalar(@{$self->{columnFamiliesToFetch}}));
      {
        foreach my $iter40 (@{$self->{columnFamiliesToFetch}})
        {
          $xfer += $output->writeString($iter40);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnsToFetch}) {
    $xfer += $output->writeFieldBegin('columnsToFetch', TType::MAP, 6);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::SET, scalar(keys %{$self->{columnsToFetch}}));
      {
        while( my ($kiter41,$viter42) = each %{$self->{columnsToFetch}}) 
        {
          $xfer += $output->writeString($kiter41);
          {
            $xfer += $output->writeSetBegin(TType::STRING, scalar(@{${viter42}}));
            {
              foreach my $iter43 (@{${viter42}})
              {
                $xfer += $output->writeString($iter43);
              }
            }
            $xfer += $output->writeSetEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{allowStaleData}) {
    $xfer += $output->writeFieldBegin('allowStaleData', TType::BOOL, 7);
    $xfer += $output->writeBool($self->{allowStaleData});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startRecord}) {
    $xfer += $output->writeFieldBegin('startRecord', TType::I32, 8);
    $xfer += $output->writeI32($self->{startRecord});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{maxRecordsToFetch}) {
    $xfer += $output->writeFieldBegin('maxRecordsToFetch', TType::I32, 9);
    $xfer += $output->writeI32($self->{maxRecordsToFetch});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{highlightOptions}) {
    $xfer += $output->writeFieldBegin('highlightOptions', TType::STRUCT, 10);
    $xfer += $self->{highlightOptions}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::FetchRowResult;
use base qw(Class::Accessor);
Blur::FetchRowResult->mk_accessors( qw( row ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{row} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'FetchRowResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{row} = new Blur::Row();
        $xfer += $self->{row}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('FetchRowResult');
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRUCT, 1);
    $xfer += $self->{row}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::FetchRecordResult;
use base qw(Class::Accessor);
Blur::FetchRecordResult->mk_accessors( qw( rowid record ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{rowid} = undef;
  $self->{record} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{rowid}) {
      $self->{rowid} = $vals->{rowid};
    }
    if (defined $vals->{record}) {
      $self->{record} = $vals->{record};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'FetchRecordResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{rowid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{record} = new Blur::Record();
        $xfer += $self->{record}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('FetchRecordResult');
  if (defined $self->{rowid}) {
    $xfer += $output->writeFieldBegin('rowid', TType::STRING, 1);
    $xfer += $output->writeString($self->{rowid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{record}) {
    $xfer += $output->writeFieldBegin('record', TType::STRUCT, 2);
    $xfer += $self->{record}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::FetchResult;
use base qw(Class::Accessor);
Blur::FetchResult->mk_accessors( qw( exists deleted table rowResult recordResult ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{exists} = undef;
  $self->{deleted} = undef;
  $self->{table} = undef;
  $self->{rowResult} = undef;
  $self->{recordResult} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{exists}) {
      $self->{exists} = $vals->{exists};
    }
    if (defined $vals->{deleted}) {
      $self->{deleted} = $vals->{deleted};
    }
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{rowResult}) {
      $self->{rowResult} = $vals->{rowResult};
    }
    if (defined $vals->{recordResult}) {
      $self->{recordResult} = $vals->{recordResult};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'FetchResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{exists});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleted});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{rowResult} = new Blur::FetchRowResult();
        $xfer += $self->{rowResult}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{recordResult} = new Blur::FetchRecordResult();
        $xfer += $self->{recordResult}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('FetchResult');
  if (defined $self->{exists}) {
    $xfer += $output->writeFieldBegin('exists', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{exists});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleted}) {
    $xfer += $output->writeFieldBegin('deleted', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{deleted});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 3);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowResult}) {
    $xfer += $output->writeFieldBegin('rowResult', TType::STRUCT, 4);
    $xfer += $self->{rowResult}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordResult}) {
    $xfer += $output->writeFieldBegin('recordResult', TType::STRUCT, 5);
    $xfer += $self->{recordResult}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::ExpertQuery;
use base qw(Class::Accessor);
Blur::ExpertQuery->mk_accessors( qw( query filter ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{query} = undef;
  $self->{filter} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{filter}) {
      $self->{filter} = $vals->{filter};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ExpertQuery';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{query});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{filter});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ExpertQuery');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRING, 1);
    $xfer += $output->writeString($self->{query});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{filter}) {
    $xfer += $output->writeFieldBegin('filter', TType::STRING, 2);
    $xfer += $output->writeString($self->{filter});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Facet;
use base qw(Class::Accessor);
Blur::Facet->mk_accessors( qw( queryStr minimumNumberOfBlurResults ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{queryStr} = undef;
  $self->{minimumNumberOfBlurResults} = 9223372036854775807;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{queryStr}) {
      $self->{queryStr} = $vals->{queryStr};
    }
    if (defined $vals->{minimumNumberOfBlurResults}) {
      $self->{minimumNumberOfBlurResults} = $vals->{minimumNumberOfBlurResults};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Facet';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{queryStr});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{minimumNumberOfBlurResults});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Facet');
  if (defined $self->{queryStr}) {
    $xfer += $output->writeFieldBegin('queryStr', TType::STRING, 1);
    $xfer += $output->writeString($self->{queryStr});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{minimumNumberOfBlurResults}) {
    $xfer += $output->writeFieldBegin('minimumNumberOfBlurResults', TType::I64, 2);
    $xfer += $output->writeI64($self->{minimumNumberOfBlurResults});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurQuery;
use base qw(Class::Accessor);
Blur::BlurQuery->mk_accessors( qw( simpleQuery expertQuery facets selector allowStaleData useCacheIfPresent start fetch minimumNumberOfResults maxQueryTime uuid userContext cacheResult startTime modifyFileCaches ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{simpleQuery} = undef;
  $self->{expertQuery} = undef;
  $self->{facets} = undef;
  $self->{selector} = undef;
  $self->{allowStaleData} = 0;
  $self->{useCacheIfPresent} = 1;
  $self->{start} = 0;
  $self->{fetch} = 10;
  $self->{minimumNumberOfResults} = 9223372036854775807;
  $self->{maxQueryTime} = 9223372036854775807;
  $self->{uuid} = undef;
  $self->{userContext} = undef;
  $self->{cacheResult} = 1;
  $self->{startTime} = 0;
  $self->{modifyFileCaches} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{simpleQuery}) {
      $self->{simpleQuery} = $vals->{simpleQuery};
    }
    if (defined $vals->{expertQuery}) {
      $self->{expertQuery} = $vals->{expertQuery};
    }
    if (defined $vals->{facets}) {
      $self->{facets} = $vals->{facets};
    }
    if (defined $vals->{selector}) {
      $self->{selector} = $vals->{selector};
    }
    if (defined $vals->{allowStaleData}) {
      $self->{allowStaleData} = $vals->{allowStaleData};
    }
    if (defined $vals->{useCacheIfPresent}) {
      $self->{useCacheIfPresent} = $vals->{useCacheIfPresent};
    }
    if (defined $vals->{start}) {
      $self->{start} = $vals->{start};
    }
    if (defined $vals->{fetch}) {
      $self->{fetch} = $vals->{fetch};
    }
    if (defined $vals->{minimumNumberOfResults}) {
      $self->{minimumNumberOfResults} = $vals->{minimumNumberOfResults};
    }
    if (defined $vals->{maxQueryTime}) {
      $self->{maxQueryTime} = $vals->{maxQueryTime};
    }
    if (defined $vals->{uuid}) {
      $self->{uuid} = $vals->{uuid};
    }
    if (defined $vals->{userContext}) {
      $self->{userContext} = $vals->{userContext};
    }
    if (defined $vals->{cacheResult}) {
      $self->{cacheResult} = $vals->{cacheResult};
    }
    if (defined $vals->{startTime}) {
      $self->{startTime} = $vals->{startTime};
    }
    if (defined $vals->{modifyFileCaches}) {
      $self->{modifyFileCaches} = $vals->{modifyFileCaches};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurQuery';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{simpleQuery} = new Blur::SimpleQuery();
        $xfer += $self->{simpleQuery}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{expertQuery} = new Blur::ExpertQuery();
        $xfer += $self->{expertQuery}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size44 = 0;
          $self->{facets} = [];
          my $_etype47 = 0;
          $xfer += $input->readListBegin(\$_etype47, \$_size44);
          for (my $_i48 = 0; $_i48 < $_size44; ++$_i48)
          {
            my $elem49 = undef;
            $elem49 = new Blur::Facet();
            $xfer += $elem49->read($input);
            push(@{$self->{facets}},$elem49);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{selector} = new Blur::Selector();
        $xfer += $self->{selector}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{allowStaleData});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{useCacheIfPresent});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{start});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{fetch});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{minimumNumberOfResults});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{maxQueryTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{uuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{userContext});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{cacheResult});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{startTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^15$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{modifyFileCaches});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurQuery');
  if (defined $self->{simpleQuery}) {
    $xfer += $output->writeFieldBegin('simpleQuery', TType::STRUCT, 1);
    $xfer += $self->{simpleQuery}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{expertQuery}) {
    $xfer += $output->writeFieldBegin('expertQuery', TType::STRUCT, 2);
    $xfer += $self->{expertQuery}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{facets}) {
    $xfer += $output->writeFieldBegin('facets', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{facets}}));
      {
        foreach my $iter50 (@{$self->{facets}}) 
        {
          $xfer += ${iter50}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{selector}) {
    $xfer += $output->writeFieldBegin('selector', TType::STRUCT, 4);
    $xfer += $self->{selector}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{allowStaleData}) {
    $xfer += $output->writeFieldBegin('allowStaleData', TType::BOOL, 5);
    $xfer += $output->writeBool($self->{allowStaleData});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{useCacheIfPresent}) {
    $xfer += $output->writeFieldBegin('useCacheIfPresent', TType::BOOL, 6);
    $xfer += $output->writeBool($self->{useCacheIfPresent});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{start}) {
    $xfer += $output->writeFieldBegin('start', TType::I64, 7);
    $xfer += $output->writeI64($self->{start});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fetch}) {
    $xfer += $output->writeFieldBegin('fetch', TType::I32, 8);
    $xfer += $output->writeI32($self->{fetch});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{minimumNumberOfResults}) {
    $xfer += $output->writeFieldBegin('minimumNumberOfResults', TType::I64, 9);
    $xfer += $output->writeI64($self->{minimumNumberOfResults});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{maxQueryTime}) {
    $xfer += $output->writeFieldBegin('maxQueryTime', TType::I64, 10);
    $xfer += $output->writeI64($self->{maxQueryTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uuid}) {
    $xfer += $output->writeFieldBegin('uuid', TType::I64, 11);
    $xfer += $output->writeI64($self->{uuid});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{userContext}) {
    $xfer += $output->writeFieldBegin('userContext', TType::STRING, 12);
    $xfer += $output->writeString($self->{userContext});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cacheResult}) {
    $xfer += $output->writeFieldBegin('cacheResult', TType::BOOL, 13);
    $xfer += $output->writeBool($self->{cacheResult});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startTime}) {
    $xfer += $output->writeFieldBegin('startTime', TType::I64, 14);
    $xfer += $output->writeI64($self->{startTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{modifyFileCaches}) {
    $xfer += $output->writeFieldBegin('modifyFileCaches', TType::BOOL, 15);
    $xfer += $output->writeBool($self->{modifyFileCaches});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurResult;
use base qw(Class::Accessor);
Blur::BlurResult->mk_accessors( qw( locationId score fetchResult ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{locationId} = undef;
  $self->{score} = undef;
  $self->{fetchResult} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{locationId}) {
      $self->{locationId} = $vals->{locationId};
    }
    if (defined $vals->{score}) {
      $self->{score} = $vals->{score};
    }
    if (defined $vals->{fetchResult}) {
      $self->{fetchResult} = $vals->{fetchResult};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{locationId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{score});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{fetchResult} = new Blur::FetchResult();
        $xfer += $self->{fetchResult}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurResult');
  if (defined $self->{locationId}) {
    $xfer += $output->writeFieldBegin('locationId', TType::STRING, 1);
    $xfer += $output->writeString($self->{locationId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{score}) {
    $xfer += $output->writeFieldBegin('score', TType::DOUBLE, 2);
    $xfer += $output->writeDouble($self->{score});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fetchResult}) {
    $xfer += $output->writeFieldBegin('fetchResult', TType::STRUCT, 3);
    $xfer += $self->{fetchResult}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurResults;
use base qw(Class::Accessor);
Blur::BlurResults->mk_accessors( qw( totalResults shardInfo results facetCounts exceptions query ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{totalResults} = 0;
  $self->{shardInfo} = undef;
  $self->{results} = undef;
  $self->{facetCounts} = undef;
  $self->{exceptions} = undef;
  $self->{query} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{totalResults}) {
      $self->{totalResults} = $vals->{totalResults};
    }
    if (defined $vals->{shardInfo}) {
      $self->{shardInfo} = $vals->{shardInfo};
    }
    if (defined $vals->{results}) {
      $self->{results} = $vals->{results};
    }
    if (defined $vals->{facetCounts}) {
      $self->{facetCounts} = $vals->{facetCounts};
    }
    if (defined $vals->{exceptions}) {
      $self->{exceptions} = $vals->{exceptions};
    }
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurResults';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{totalResults});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size51 = 0;
          $self->{shardInfo} = {};
          my $_ktype52 = 0;
          my $_vtype53 = 0;
          $xfer += $input->readMapBegin(\$_ktype52, \$_vtype53, \$_size51);
          for (my $_i55 = 0; $_i55 < $_size51; ++$_i55)
          {
            my $key56 = '';
            my $val57 = 0;
            $xfer += $input->readString(\$key56);
            $xfer += $input->readI64(\$val57);
            $self->{shardInfo}->{$key56} = $val57;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size58 = 0;
          $self->{results} = [];
          my $_etype61 = 0;
          $xfer += $input->readListBegin(\$_etype61, \$_size58);
          for (my $_i62 = 0; $_i62 < $_size58; ++$_i62)
          {
            my $elem63 = undef;
            $elem63 = new Blur::BlurResult();
            $xfer += $elem63->read($input);
            push(@{$self->{results}},$elem63);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size64 = 0;
          $self->{facetCounts} = [];
          my $_etype67 = 0;
          $xfer += $input->readListBegin(\$_etype67, \$_size64);
          for (my $_i68 = 0; $_i68 < $_size64; ++$_i68)
          {
            my $elem69 = undef;
            $xfer += $input->readI64(\$elem69);
            push(@{$self->{facetCounts}},$elem69);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size70 = 0;
          $self->{exceptions} = [];
          my $_etype73 = 0;
          $xfer += $input->readListBegin(\$_etype73, \$_size70);
          for (my $_i74 = 0; $_i74 < $_size70; ++$_i74)
          {
            my $elem75 = undef;
            $elem75 = new Blur::BlurException();
            $xfer += $elem75->read($input);
            push(@{$self->{exceptions}},$elem75);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{query} = new Blur::BlurQuery();
        $xfer += $self->{query}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurResults');
  if (defined $self->{totalResults}) {
    $xfer += $output->writeFieldBegin('totalResults', TType::I64, 1);
    $xfer += $output->writeI64($self->{totalResults});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{shardInfo}) {
    $xfer += $output->writeFieldBegin('shardInfo', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::I64, scalar(keys %{$self->{shardInfo}}));
      {
        while( my ($kiter76,$viter77) = each %{$self->{shardInfo}}) 
        {
          $xfer += $output->writeString($kiter76);
          $xfer += $output->writeI64($viter77);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{results}) {
    $xfer += $output->writeFieldBegin('results', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{results}}));
      {
        foreach my $iter78 (@{$self->{results}}) 
        {
          $xfer += ${iter78}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{facetCounts}) {
    $xfer += $output->writeFieldBegin('facetCounts', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::I64, scalar(@{$self->{facetCounts}}));
      {
        foreach my $iter79 (@{$self->{facetCounts}}) 
        {
          $xfer += $output->writeI64($iter79);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{exceptions}) {
    $xfer += $output->writeFieldBegin('exceptions', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{exceptions}}));
      {
        foreach my $iter80 (@{$self->{exceptions}}) 
        {
          $xfer += ${iter80}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRUCT, 6);
    $xfer += $self->{query}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::RecordMutation;
use base qw(Class::Accessor);
Blur::RecordMutation->mk_accessors( qw( recordMutationType record ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{recordMutationType} = undef;
  $self->{record} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{recordMutationType}) {
      $self->{recordMutationType} = $vals->{recordMutationType};
    }
    if (defined $vals->{record}) {
      $self->{record} = $vals->{record};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RecordMutation';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{recordMutationType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{record} = new Blur::Record();
        $xfer += $self->{record}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RecordMutation');
  if (defined $self->{recordMutationType}) {
    $xfer += $output->writeFieldBegin('recordMutationType', TType::I32, 1);
    $xfer += $output->writeI32($self->{recordMutationType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{record}) {
    $xfer += $output->writeFieldBegin('record', TType::STRUCT, 2);
    $xfer += $self->{record}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::RowMutation;
use base qw(Class::Accessor);
Blur::RowMutation->mk_accessors( qw( table rowId wal rowMutationType recordMutations waitToBeVisible ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{rowId} = undef;
  $self->{wal} = 1;
  $self->{rowMutationType} = undef;
  $self->{recordMutations} = undef;
  $self->{waitToBeVisible} = 0;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{rowId}) {
      $self->{rowId} = $vals->{rowId};
    }
    if (defined $vals->{wal}) {
      $self->{wal} = $vals->{wal};
    }
    if (defined $vals->{rowMutationType}) {
      $self->{rowMutationType} = $vals->{rowMutationType};
    }
    if (defined $vals->{recordMutations}) {
      $self->{recordMutations} = $vals->{recordMutations};
    }
    if (defined $vals->{waitToBeVisible}) {
      $self->{waitToBeVisible} = $vals->{waitToBeVisible};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'RowMutation';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{rowId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{wal});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{rowMutationType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size81 = 0;
          $self->{recordMutations} = [];
          my $_etype84 = 0;
          $xfer += $input->readListBegin(\$_etype84, \$_size81);
          for (my $_i85 = 0; $_i85 < $_size81; ++$_i85)
          {
            my $elem86 = undef;
            $elem86 = new Blur::RecordMutation();
            $xfer += $elem86->read($input);
            push(@{$self->{recordMutations}},$elem86);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{waitToBeVisible});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RowMutation');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowId}) {
    $xfer += $output->writeFieldBegin('rowId', TType::STRING, 2);
    $xfer += $output->writeString($self->{rowId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{wal}) {
    $xfer += $output->writeFieldBegin('wal', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{wal});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowMutationType}) {
    $xfer += $output->writeFieldBegin('rowMutationType', TType::I32, 4);
    $xfer += $output->writeI32($self->{rowMutationType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordMutations}) {
    $xfer += $output->writeFieldBegin('recordMutations', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{recordMutations}}));
      {
        foreach my $iter87 (@{$self->{recordMutations}}) 
        {
          $xfer += ${iter87}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{waitToBeVisible}) {
    $xfer += $output->writeFieldBegin('waitToBeVisible', TType::BOOL, 6);
    $xfer += $output->writeBool($self->{waitToBeVisible});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::CpuTime;
use base qw(Class::Accessor);
Blur::CpuTime->mk_accessors( qw( cpuTime realTime ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cpuTime} = undef;
  $self->{realTime} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cpuTime}) {
      $self->{cpuTime} = $vals->{cpuTime};
    }
    if (defined $vals->{realTime}) {
      $self->{realTime} = $vals->{realTime};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'CpuTime';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{cpuTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{realTime});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('CpuTime');
  if (defined $self->{cpuTime}) {
    $xfer += $output->writeFieldBegin('cpuTime', TType::I64, 1);
    $xfer += $output->writeI64($self->{cpuTime});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{realTime}) {
    $xfer += $output->writeFieldBegin('realTime', TType::I64, 2);
    $xfer += $output->writeI64($self->{realTime});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurQueryStatus;
use base qw(Class::Accessor);
Blur::BlurQueryStatus->mk_accessors( qw( query cpuTimes completeShards totalShards state uuid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{query} = undef;
  $self->{cpuTimes} = undef;
  $self->{completeShards} = undef;
  $self->{totalShards} = undef;
  $self->{state} = undef;
  $self->{uuid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{query}) {
      $self->{query} = $vals->{query};
    }
    if (defined $vals->{cpuTimes}) {
      $self->{cpuTimes} = $vals->{cpuTimes};
    }
    if (defined $vals->{completeShards}) {
      $self->{completeShards} = $vals->{completeShards};
    }
    if (defined $vals->{totalShards}) {
      $self->{totalShards} = $vals->{totalShards};
    }
    if (defined $vals->{state}) {
      $self->{state} = $vals->{state};
    }
    if (defined $vals->{uuid}) {
      $self->{uuid} = $vals->{uuid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'BlurQueryStatus';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{query} = new Blur::BlurQuery();
        $xfer += $self->{query}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size88 = 0;
          $self->{cpuTimes} = {};
          my $_ktype89 = 0;
          my $_vtype90 = 0;
          $xfer += $input->readMapBegin(\$_ktype89, \$_vtype90, \$_size88);
          for (my $_i92 = 0; $_i92 < $_size88; ++$_i92)
          {
            my $key93 = '';
            my $val94 = new Blur::CpuTime();
            $xfer += $input->readString(\$key93);
            $val94 = new Blur::CpuTime();
            $xfer += $val94->read($input);
            $self->{cpuTimes}->{$key93} = $val94;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{completeShards});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{totalShards});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{state});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{uuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('BlurQueryStatus');
  if (defined $self->{query}) {
    $xfer += $output->writeFieldBegin('query', TType::STRUCT, 1);
    $xfer += $self->{query}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cpuTimes}) {
    $xfer += $output->writeFieldBegin('cpuTimes', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{cpuTimes}}));
      {
        while( my ($kiter95,$viter96) = each %{$self->{cpuTimes}}) 
        {
          $xfer += $output->writeString($kiter95);
          $xfer += ${viter96}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{completeShards}) {
    $xfer += $output->writeFieldBegin('completeShards', TType::I32, 3);
    $xfer += $output->writeI32($self->{completeShards});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{totalShards}) {
    $xfer += $output->writeFieldBegin('totalShards', TType::I32, 4);
    $xfer += $output->writeI32($self->{totalShards});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{state}) {
    $xfer += $output->writeFieldBegin('state', TType::I32, 5);
    $xfer += $output->writeI32($self->{state});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uuid}) {
    $xfer += $output->writeFieldBegin('uuid', TType::I64, 6);
    $xfer += $output->writeI64($self->{uuid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::TableStats;
use base qw(Class::Accessor);
Blur::TableStats->mk_accessors( qw( tableName bytes recordCount rowCount queries ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{bytes} = undef;
  $self->{recordCount} = undef;
  $self->{rowCount} = undef;
  $self->{queries} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{bytes}) {
      $self->{bytes} = $vals->{bytes};
    }
    if (defined $vals->{recordCount}) {
      $self->{recordCount} = $vals->{recordCount};
    }
    if (defined $vals->{rowCount}) {
      $self->{rowCount} = $vals->{rowCount};
    }
    if (defined $vals->{queries}) {
      $self->{queries} = $vals->{queries};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TableStats';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{bytes});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{recordCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{rowCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{queries});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TableStats');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{bytes}) {
    $xfer += $output->writeFieldBegin('bytes', TType::I64, 2);
    $xfer += $output->writeI64($self->{bytes});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{recordCount}) {
    $xfer += $output->writeFieldBegin('recordCount', TType::I64, 3);
    $xfer += $output->writeI64($self->{recordCount});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowCount}) {
    $xfer += $output->writeFieldBegin('rowCount', TType::I64, 4);
    $xfer += $output->writeI64($self->{rowCount});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{queries}) {
    $xfer += $output->writeFieldBegin('queries', TType::I64, 5);
    $xfer += $output->writeI64($self->{queries});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Schema;
use base qw(Class::Accessor);
Blur::Schema->mk_accessors( qw( table columnFamilies ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{columnFamilies} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{columnFamilies}) {
      $self->{columnFamilies} = $vals->{columnFamilies};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Schema';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size97 = 0;
          $self->{columnFamilies} = {};
          my $_ktype98 = 0;
          my $_vtype99 = 0;
          $xfer += $input->readMapBegin(\$_ktype98, \$_vtype99, \$_size97);
          for (my $_i101 = 0; $_i101 < $_size97; ++$_i101)
          {
            my $key102 = '';
            my $val103 = [];
            $xfer += $input->readString(\$key102);
            {
              my $_size104 = 0;
              $val103 = {};
              my $_etype107 = 0;
              $xfer += $input->readSetBegin(\$_etype107, \$_size104);
              for (my $_i108 = 0; $_i108 < $_size104; ++$_i108)
              {
                my $elem109 = undef;
                $xfer += $input->readString(\$elem109);
                $val103->{$elem109} = 1;
              }
              $xfer += $input->readSetEnd();
            }
            $self->{columnFamilies}->{$key102} = $val103;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Schema');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamilies}) {
    $xfer += $output->writeFieldBegin('columnFamilies', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::SET, scalar(keys %{$self->{columnFamilies}}));
      {
        while( my ($kiter110,$viter111) = each %{$self->{columnFamilies}}) 
        {
          $xfer += $output->writeString($kiter110);
          {
            $xfer += $output->writeSetBegin(TType::STRING, scalar(@{${viter111}}));
            {
              foreach my $iter112 (@{${viter111}})
              {
                $xfer += $output->writeString($iter112);
              }
            }
            $xfer += $output->writeSetEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::AlternateColumnDefinition;
use base qw(Class::Accessor);
Blur::AlternateColumnDefinition->mk_accessors( qw( analyzerClassName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{analyzerClassName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{analyzerClassName}) {
      $self->{analyzerClassName} = $vals->{analyzerClassName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AlternateColumnDefinition';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{analyzerClassName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AlternateColumnDefinition');
  if (defined $self->{analyzerClassName}) {
    $xfer += $output->writeFieldBegin('analyzerClassName', TType::STRING, 1);
    $xfer += $output->writeString($self->{analyzerClassName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::ColumnDefinition;
use base qw(Class::Accessor);
Blur::ColumnDefinition->mk_accessors( qw( analyzerClassName fullTextIndex alternateColumnDefinitions ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{analyzerClassName} = "org.apache.lucene.analysis.standard.StandardAnalyzer";
  $self->{fullTextIndex} = undef;
  $self->{alternateColumnDefinitions} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{analyzerClassName}) {
      $self->{analyzerClassName} = $vals->{analyzerClassName};
    }
    if (defined $vals->{fullTextIndex}) {
      $self->{fullTextIndex} = $vals->{fullTextIndex};
    }
    if (defined $vals->{alternateColumnDefinitions}) {
      $self->{alternateColumnDefinitions} = $vals->{alternateColumnDefinitions};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnDefinition';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{analyzerClassName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{fullTextIndex});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size113 = 0;
          $self->{alternateColumnDefinitions} = {};
          my $_ktype114 = 0;
          my $_vtype115 = 0;
          $xfer += $input->readMapBegin(\$_ktype114, \$_vtype115, \$_size113);
          for (my $_i117 = 0; $_i117 < $_size113; ++$_i117)
          {
            my $key118 = '';
            my $val119 = new Blur::AlternateColumnDefinition();
            $xfer += $input->readString(\$key118);
            $val119 = new Blur::AlternateColumnDefinition();
            $xfer += $val119->read($input);
            $self->{alternateColumnDefinitions}->{$key118} = $val119;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnDefinition');
  if (defined $self->{analyzerClassName}) {
    $xfer += $output->writeFieldBegin('analyzerClassName', TType::STRING, 1);
    $xfer += $output->writeString($self->{analyzerClassName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fullTextIndex}) {
    $xfer += $output->writeFieldBegin('fullTextIndex', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{fullTextIndex});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{alternateColumnDefinitions}) {
    $xfer += $output->writeFieldBegin('alternateColumnDefinitions', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{alternateColumnDefinitions}}));
      {
        while( my ($kiter120,$viter121) = each %{$self->{alternateColumnDefinitions}}) 
        {
          $xfer += $output->writeString($kiter120);
          $xfer += ${viter121}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::ColumnFamilyDefinition;
use base qw(Class::Accessor);
Blur::ColumnFamilyDefinition->mk_accessors( qw( defaultDefinition columnDefinitions ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{defaultDefinition} = undef;
  $self->{columnDefinitions} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{defaultDefinition}) {
      $self->{defaultDefinition} = $vals->{defaultDefinition};
    }
    if (defined $vals->{columnDefinitions}) {
      $self->{columnDefinitions} = $vals->{columnDefinitions};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnFamilyDefinition';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{defaultDefinition} = new Blur::ColumnDefinition();
        $xfer += $self->{defaultDefinition}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size122 = 0;
          $self->{columnDefinitions} = {};
          my $_ktype123 = 0;
          my $_vtype124 = 0;
          $xfer += $input->readMapBegin(\$_ktype123, \$_vtype124, \$_size122);
          for (my $_i126 = 0; $_i126 < $_size122; ++$_i126)
          {
            my $key127 = '';
            my $val128 = new Blur::ColumnDefinition();
            $xfer += $input->readString(\$key127);
            $val128 = new Blur::ColumnDefinition();
            $xfer += $val128->read($input);
            $self->{columnDefinitions}->{$key127} = $val128;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnFamilyDefinition');
  if (defined $self->{defaultDefinition}) {
    $xfer += $output->writeFieldBegin('defaultDefinition', TType::STRUCT, 1);
    $xfer += $self->{defaultDefinition}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnDefinitions}) {
    $xfer += $output->writeFieldBegin('columnDefinitions', TType::MAP, 2);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{columnDefinitions}}));
      {
        while( my ($kiter129,$viter130) = each %{$self->{columnDefinitions}}) 
        {
          $xfer += $output->writeString($kiter129);
          $xfer += ${viter130}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::AnalyzerDefinition;
use base qw(Class::Accessor);
Blur::AnalyzerDefinition->mk_accessors( qw( defaultDefinition fullTextAnalyzerClassName columnFamilyDefinitions ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{defaultDefinition} = undef;
  $self->{fullTextAnalyzerClassName} = "org.apache.lucene.analysis.standard.StandardAnalyzer";
  $self->{columnFamilyDefinitions} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{defaultDefinition}) {
      $self->{defaultDefinition} = $vals->{defaultDefinition};
    }
    if (defined $vals->{fullTextAnalyzerClassName}) {
      $self->{fullTextAnalyzerClassName} = $vals->{fullTextAnalyzerClassName};
    }
    if (defined $vals->{columnFamilyDefinitions}) {
      $self->{columnFamilyDefinitions} = $vals->{columnFamilyDefinitions};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'AnalyzerDefinition';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{defaultDefinition} = new Blur::ColumnDefinition();
        $xfer += $self->{defaultDefinition}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{fullTextAnalyzerClassName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size131 = 0;
          $self->{columnFamilyDefinitions} = {};
          my $_ktype132 = 0;
          my $_vtype133 = 0;
          $xfer += $input->readMapBegin(\$_ktype132, \$_vtype133, \$_size131);
          for (my $_i135 = 0; $_i135 < $_size131; ++$_i135)
          {
            my $key136 = '';
            my $val137 = new Blur::ColumnFamilyDefinition();
            $xfer += $input->readString(\$key136);
            $val137 = new Blur::ColumnFamilyDefinition();
            $xfer += $val137->read($input);
            $self->{columnFamilyDefinitions}->{$key136} = $val137;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('AnalyzerDefinition');
  if (defined $self->{defaultDefinition}) {
    $xfer += $output->writeFieldBegin('defaultDefinition', TType::STRUCT, 1);
    $xfer += $self->{defaultDefinition}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{fullTextAnalyzerClassName}) {
    $xfer += $output->writeFieldBegin('fullTextAnalyzerClassName', TType::STRING, 2);
    $xfer += $output->writeString($self->{fullTextAnalyzerClassName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamilyDefinitions}) {
    $xfer += $output->writeFieldBegin('columnFamilyDefinitions', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{columnFamilyDefinitions}}));
      {
        while( my ($kiter138,$viter139) = each %{$self->{columnFamilyDefinitions}}) 
        {
          $xfer += $output->writeString($kiter138);
          $xfer += ${viter139}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::ColumnPreCache;
use base qw(Class::Accessor);
Blur::ColumnPreCache->mk_accessors( qw( preCacheCols ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{preCacheCols} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{preCacheCols}) {
      $self->{preCacheCols} = $vals->{preCacheCols};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'ColumnPreCache';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size140 = 0;
          $self->{preCacheCols} = [];
          my $_etype143 = 0;
          $xfer += $input->readListBegin(\$_etype143, \$_size140);
          for (my $_i144 = 0; $_i144 < $_size140; ++$_i144)
          {
            my $elem145 = undef;
            $xfer += $input->readString(\$elem145);
            push(@{$self->{preCacheCols}},$elem145);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('ColumnPreCache');
  if (defined $self->{preCacheCols}) {
    $xfer += $output->writeFieldBegin('preCacheCols', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{preCacheCols}}));
      {
        foreach my $iter146 (@{$self->{preCacheCols}}) 
        {
          $xfer += $output->writeString($iter146);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::TableDescriptor;
use base qw(Class::Accessor);
Blur::TableDescriptor->mk_accessors( qw( isEnabled analyzerDefinition shardCount tableUri compressionClass compressionBlockSize cluster name similarityClass blockCaching blockCachingFileTypes readOnly columnPreCache tableProperties ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{isEnabled} = 1;
  $self->{analyzerDefinition} = undef;
  $self->{shardCount} = 1;
  $self->{tableUri} = undef;
  $self->{compressionClass} = "org.apache.hadoop.io.compress.DefaultCodec";
  $self->{compressionBlockSize} = 32768;
  $self->{cluster} = "default";
  $self->{name} = undef;
  $self->{similarityClass} = undef;
  $self->{blockCaching} = 1;
  $self->{blockCachingFileTypes} = undef;
  $self->{readOnly} = 0;
  $self->{columnPreCache} = undef;
  $self->{tableProperties} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{isEnabled}) {
      $self->{isEnabled} = $vals->{isEnabled};
    }
    if (defined $vals->{analyzerDefinition}) {
      $self->{analyzerDefinition} = $vals->{analyzerDefinition};
    }
    if (defined $vals->{shardCount}) {
      $self->{shardCount} = $vals->{shardCount};
    }
    if (defined $vals->{tableUri}) {
      $self->{tableUri} = $vals->{tableUri};
    }
    if (defined $vals->{compressionClass}) {
      $self->{compressionClass} = $vals->{compressionClass};
    }
    if (defined $vals->{compressionBlockSize}) {
      $self->{compressionBlockSize} = $vals->{compressionBlockSize};
    }
    if (defined $vals->{cluster}) {
      $self->{cluster} = $vals->{cluster};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{similarityClass}) {
      $self->{similarityClass} = $vals->{similarityClass};
    }
    if (defined $vals->{blockCaching}) {
      $self->{blockCaching} = $vals->{blockCaching};
    }
    if (defined $vals->{blockCachingFileTypes}) {
      $self->{blockCachingFileTypes} = $vals->{blockCachingFileTypes};
    }
    if (defined $vals->{readOnly}) {
      $self->{readOnly} = $vals->{readOnly};
    }
    if (defined $vals->{columnPreCache}) {
      $self->{columnPreCache} = $vals->{columnPreCache};
    }
    if (defined $vals->{tableProperties}) {
      $self->{tableProperties} = $vals->{tableProperties};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TableDescriptor';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{isEnabled});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{analyzerDefinition} = new Blur::AnalyzerDefinition();
        $xfer += $self->{analyzerDefinition}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{shardCount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableUri});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{compressionClass});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{compressionBlockSize});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cluster});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{similarityClass});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{blockCaching});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::SET) {
        {
          my $_size147 = 0;
          $self->{blockCachingFileTypes} = {};
          my $_etype150 = 0;
          $xfer += $input->readSetBegin(\$_etype150, \$_size147);
          for (my $_i151 = 0; $_i151 < $_size147; ++$_i151)
          {
            my $elem152 = undef;
            $xfer += $input->readString(\$elem152);
            $self->{blockCachingFileTypes}->{$elem152} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{readOnly});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{columnPreCache} = new Blur::ColumnPreCache();
        $xfer += $self->{columnPreCache}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size153 = 0;
          $self->{tableProperties} = {};
          my $_ktype154 = 0;
          my $_vtype155 = 0;
          $xfer += $input->readMapBegin(\$_ktype154, \$_vtype155, \$_size153);
          for (my $_i157 = 0; $_i157 < $_size153; ++$_i157)
          {
            my $key158 = '';
            my $val159 = '';
            $xfer += $input->readString(\$key158);
            $xfer += $input->readString(\$val159);
            $self->{tableProperties}->{$key158} = $val159;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TableDescriptor');
  if (defined $self->{isEnabled}) {
    $xfer += $output->writeFieldBegin('isEnabled', TType::BOOL, 1);
    $xfer += $output->writeBool($self->{isEnabled});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{analyzerDefinition}) {
    $xfer += $output->writeFieldBegin('analyzerDefinition', TType::STRUCT, 2);
    $xfer += $self->{analyzerDefinition}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{shardCount}) {
    $xfer += $output->writeFieldBegin('shardCount', TType::I32, 3);
    $xfer += $output->writeI32($self->{shardCount});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tableUri}) {
    $xfer += $output->writeFieldBegin('tableUri', TType::STRING, 4);
    $xfer += $output->writeString($self->{tableUri});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compressionClass}) {
    $xfer += $output->writeFieldBegin('compressionClass', TType::STRING, 5);
    $xfer += $output->writeString($self->{compressionClass});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{compressionBlockSize}) {
    $xfer += $output->writeFieldBegin('compressionBlockSize', TType::I32, 6);
    $xfer += $output->writeI32($self->{compressionBlockSize});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{cluster}) {
    $xfer += $output->writeFieldBegin('cluster', TType::STRING, 7);
    $xfer += $output->writeString($self->{cluster});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 8);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{similarityClass}) {
    $xfer += $output->writeFieldBegin('similarityClass', TType::STRING, 9);
    $xfer += $output->writeString($self->{similarityClass});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{blockCaching}) {
    $xfer += $output->writeFieldBegin('blockCaching', TType::BOOL, 10);
    $xfer += $output->writeBool($self->{blockCaching});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{blockCachingFileTypes}) {
    $xfer += $output->writeFieldBegin('blockCachingFileTypes', TType::SET, 11);
    {
      $xfer += $output->writeSetBegin(TType::STRING, scalar(@{$self->{blockCachingFileTypes}}));
      {
        foreach my $iter160 (@{$self->{blockCachingFileTypes}})
        {
          $xfer += $output->writeString($iter160);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{readOnly}) {
    $xfer += $output->writeFieldBegin('readOnly', TType::BOOL, 12);
    $xfer += $output->writeBool($self->{readOnly});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnPreCache}) {
    $xfer += $output->writeFieldBegin('columnPreCache', TType::STRUCT, 13);
    $xfer += $self->{columnPreCache}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{tableProperties}) {
    $xfer += $output->writeFieldBegin('tableProperties', TType::MAP, 14);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{tableProperties}}));
      {
        while( my ($kiter161,$viter162) = each %{$self->{tableProperties}}) 
        {
          $xfer += $output->writeString($kiter161);
          $xfer += $output->writeString($viter162);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;
