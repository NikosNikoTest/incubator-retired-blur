#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use Blur::Types;

# HELPER FUNCTIONS AND STRUCTURES

package Blur::Blur_shardClusterList_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardClusterList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardClusterList_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardClusterList_result;
use base qw(Class::Accessor);
Blur::Blur_shardClusterList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardClusterList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size174 = 0;
          $self->{success} = [];
          my $_etype177 = 0;
          $xfer += $input->readListBegin(\$_etype177, \$_size174);
          for (my $_i178 = 0; $_i178 < $_size174; ++$_i178)
          {
            my $elem179 = undef;
            $xfer += $input->readString(\$elem179);
            push(@{$self->{success}},$elem179);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardClusterList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter180 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter180);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardServerList_args;
use base qw(Class::Accessor);
Blur::Blur_shardServerList_args->mk_accessors( qw( cluster ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cluster} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cluster}) {
      $self->{cluster} = $vals->{cluster};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardServerList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cluster});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardServerList_args');
  if (defined $self->{cluster}) {
    $xfer += $output->writeFieldBegin('cluster', TType::STRING, 1);
    $xfer += $output->writeString($self->{cluster});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardServerList_result;
use base qw(Class::Accessor);
Blur::Blur_shardServerList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardServerList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size181 = 0;
          $self->{success} = [];
          my $_etype184 = 0;
          $xfer += $input->readListBegin(\$_etype184, \$_size181);
          for (my $_i185 = 0; $_i185 < $_size181; ++$_i185)
          {
            my $elem186 = undef;
            $xfer += $input->readString(\$elem186);
            push(@{$self->{success}},$elem186);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardServerList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter187 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter187);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_controllerServerList_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_controllerServerList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_controllerServerList_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_controllerServerList_result;
use base qw(Class::Accessor);
Blur::Blur_controllerServerList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_controllerServerList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size188 = 0;
          $self->{success} = [];
          my $_etype191 = 0;
          $xfer += $input->readListBegin(\$_etype191, \$_size188);
          for (my $_i192 = 0; $_i192 < $_size188; ++$_i192)
          {
            my $elem193 = undef;
            $xfer += $input->readString(\$elem193);
            push(@{$self->{success}},$elem193);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_controllerServerList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter194 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter194);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardServerLayout_args;
use base qw(Class::Accessor);
Blur::Blur_shardServerLayout_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardServerLayout_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardServerLayout_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardServerLayout_result;
use base qw(Class::Accessor);
Blur::Blur_shardServerLayout_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardServerLayout_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size195 = 0;
          $self->{success} = {};
          my $_ktype196 = 0;
          my $_vtype197 = 0;
          $xfer += $input->readMapBegin(\$_ktype196, \$_vtype197, \$_size195);
          for (my $_i199 = 0; $_i199 < $_size195; ++$_i199)
          {
            my $key200 = '';
            my $val201 = '';
            $xfer += $input->readString(\$key200);
            $xfer += $input->readString(\$val201);
            $self->{success}->{$key200} = $val201;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardServerLayout_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter202,$viter203) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter202);
          $xfer += $output->writeString($viter203);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardServerLayoutState_args;
use base qw(Class::Accessor);
Blur::Blur_shardServerLayoutState_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardServerLayoutState_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardServerLayoutState_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_shardServerLayoutState_result;
use base qw(Class::Accessor);
Blur::Blur_shardServerLayoutState_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_shardServerLayoutState_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size204 = 0;
          $self->{success} = {};
          my $_ktype205 = 0;
          my $_vtype206 = 0;
          $xfer += $input->readMapBegin(\$_ktype205, \$_vtype206, \$_size204);
          for (my $_i208 = 0; $_i208 < $_size204; ++$_i208)
          {
            my $key209 = '';
            my $val210 = [];
            $xfer += $input->readString(\$key209);
            {
              my $_size211 = 0;
              $val210 = {};
              my $_ktype212 = 0;
              my $_vtype213 = 0;
              $xfer += $input->readMapBegin(\$_ktype212, \$_vtype213, \$_size211);
              for (my $_i215 = 0; $_i215 < $_size211; ++$_i215)
              {
                my $key216 = '';
                my $val217 = 0;
                $xfer += $input->readString(\$key216);
                $xfer += $input->readI32(\$val217);
                $val210->{$key216} = $val217;
              }
              $xfer += $input->readMapEnd();
            }
            $self->{success}->{$key209} = $val210;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_shardServerLayoutState_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::MAP, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter218,$viter219) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter218);
          {
            $xfer += $output->writeMapBegin(TType::STRING, TType::I32, scalar(keys %{${viter219}}));
            {
              while( my ($kiter220,$viter221) = each %{${viter219}}) 
              {
                $xfer += $output->writeString($kiter220);
                $xfer += $output->writeI32($viter221);
              }
            }
            $xfer += $output->writeMapEnd();
          }
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_tableList_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_tableList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_tableList_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_tableList_result;
use base qw(Class::Accessor);
Blur::Blur_tableList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_tableList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size222 = 0;
          $self->{success} = [];
          my $_etype225 = 0;
          $xfer += $input->readListBegin(\$_etype225, \$_size222);
          for (my $_i226 = 0; $_i226 < $_size222; ++$_i226)
          {
            my $elem227 = undef;
            $xfer += $input->readString(\$elem227);
            push(@{$self->{success}},$elem227);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_tableList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter228 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter228);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_tableListByCluster_args;
use base qw(Class::Accessor);
Blur::Blur_tableListByCluster_args->mk_accessors( qw( cluster ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cluster} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cluster}) {
      $self->{cluster} = $vals->{cluster};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_tableListByCluster_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cluster});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_tableListByCluster_args');
  if (defined $self->{cluster}) {
    $xfer += $output->writeFieldBegin('cluster', TType::STRING, 1);
    $xfer += $output->writeString($self->{cluster});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_tableListByCluster_result;
use base qw(Class::Accessor);
Blur::Blur_tableListByCluster_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_tableListByCluster_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size229 = 0;
          $self->{success} = [];
          my $_etype232 = 0;
          $xfer += $input->readListBegin(\$_etype232, \$_size229);
          for (my $_i233 = 0; $_i233 < $_size229; ++$_i233)
          {
            my $elem234 = undef;
            $xfer += $input->readString(\$elem234);
            push(@{$self->{success}},$elem234);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_tableListByCluster_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter235 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter235);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_describe_args;
use base qw(Class::Accessor);
Blur::Blur_describe_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_describe_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_describe_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_describe_result;
use base qw(Class::Accessor);
Blur::Blur_describe_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_describe_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::TableDescriptor();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_describe_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_query_args;
use base qw(Class::Accessor);
Blur::Blur_query_args->mk_accessors( qw( table blurQuery ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{blurQuery} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{blurQuery}) {
      $self->{blurQuery} = $vals->{blurQuery};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_query_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{blurQuery} = new Blur::BlurQuery();
        $xfer += $self->{blurQuery}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_query_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{blurQuery}) {
    $xfer += $output->writeFieldBegin('blurQuery', TType::STRUCT, 2);
    $xfer += $self->{blurQuery}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_query_result;
use base qw(Class::Accessor);
Blur::Blur_query_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_query_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::BlurResults();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_query_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_parseQuery_args;
use base qw(Class::Accessor);
Blur::Blur_parseQuery_args->mk_accessors( qw( table simpleQuery ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{simpleQuery} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{simpleQuery}) {
      $self->{simpleQuery} = $vals->{simpleQuery};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_parseQuery_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{simpleQuery} = new Blur::SimpleQuery();
        $xfer += $self->{simpleQuery}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_parseQuery_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{simpleQuery}) {
    $xfer += $output->writeFieldBegin('simpleQuery', TType::STRUCT, 2);
    $xfer += $self->{simpleQuery}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_parseQuery_result;
use base qw(Class::Accessor);
Blur::Blur_parseQuery_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_parseQuery_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_parseQuery_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_cancelQuery_args;
use base qw(Class::Accessor);
Blur::Blur_cancelQuery_args->mk_accessors( qw( table uuid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{uuid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{uuid}) {
      $self->{uuid} = $vals->{uuid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_cancelQuery_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{uuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_cancelQuery_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uuid}) {
    $xfer += $output->writeFieldBegin('uuid', TType::I64, 2);
    $xfer += $output->writeI64($self->{uuid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_cancelQuery_result;
use base qw(Class::Accessor);
Blur::Blur_cancelQuery_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_cancelQuery_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_cancelQuery_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_currentQueries_args;
use base qw(Class::Accessor);
Blur::Blur_currentQueries_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_currentQueries_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_currentQueries_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_currentQueries_result;
use base qw(Class::Accessor);
Blur::Blur_currentQueries_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_currentQueries_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size236 = 0;
          $self->{success} = [];
          my $_etype239 = 0;
          $xfer += $input->readListBegin(\$_etype239, \$_size236);
          for (my $_i240 = 0; $_i240 < $_size236; ++$_i240)
          {
            my $elem241 = undef;
            $elem241 = new Blur::BlurQueryStatus();
            $xfer += $elem241->read($input);
            push(@{$self->{success}},$elem241);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_currentQueries_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter242 (@{$self->{success}}) 
        {
          $xfer += ${iter242}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_queryStatusIdList_args;
use base qw(Class::Accessor);
Blur::Blur_queryStatusIdList_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_queryStatusIdList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_queryStatusIdList_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_queryStatusIdList_result;
use base qw(Class::Accessor);
Blur::Blur_queryStatusIdList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_queryStatusIdList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size243 = 0;
          $self->{success} = [];
          my $_etype246 = 0;
          $xfer += $input->readListBegin(\$_etype246, \$_size243);
          for (my $_i247 = 0; $_i247 < $_size243; ++$_i247)
          {
            my $elem248 = undef;
            $xfer += $input->readI64(\$elem248);
            push(@{$self->{success}},$elem248);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_queryStatusIdList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::I64, scalar(@{$self->{success}}));
      {
        foreach my $iter249 (@{$self->{success}}) 
        {
          $xfer += $output->writeI64($iter249);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_queryStatusById_args;
use base qw(Class::Accessor);
Blur::Blur_queryStatusById_args->mk_accessors( qw( table uuid ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{uuid} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{uuid}) {
      $self->{uuid} = $vals->{uuid};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_queryStatusById_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{uuid});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_queryStatusById_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uuid}) {
    $xfer += $output->writeFieldBegin('uuid', TType::I64, 2);
    $xfer += $output->writeI64($self->{uuid});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_queryStatusById_result;
use base qw(Class::Accessor);
Blur::Blur_queryStatusById_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_queryStatusById_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::BlurQueryStatus();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_queryStatusById_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_schema_args;
use base qw(Class::Accessor);
Blur::Blur_schema_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_schema_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_schema_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_schema_result;
use base qw(Class::Accessor);
Blur::Blur_schema_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_schema_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::Schema();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_schema_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_getTableStats_args;
use base qw(Class::Accessor);
Blur::Blur_getTableStats_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_getTableStats_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_getTableStats_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_getTableStats_result;
use base qw(Class::Accessor);
Blur::Blur_getTableStats_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_getTableStats_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::TableStats();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_getTableStats_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_tableStats_args;
use base qw(Class::Accessor);
Blur::Blur_tableStats_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_tableStats_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_tableStats_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_tableStats_result;
use base qw(Class::Accessor);
Blur::Blur_tableStats_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_tableStats_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::TableStats();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_tableStats_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_terms_args;
use base qw(Class::Accessor);
Blur::Blur_terms_args->mk_accessors( qw( table columnFamily columnName startWith size ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{columnFamily} = undef;
  $self->{columnName} = undef;
  $self->{startWith} = undef;
  $self->{size} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{columnFamily}) {
      $self->{columnFamily} = $vals->{columnFamily};
    }
    if (defined $vals->{columnName}) {
      $self->{columnName} = $vals->{columnName};
    }
    if (defined $vals->{startWith}) {
      $self->{startWith} = $vals->{startWith};
    }
    if (defined $vals->{size}) {
      $self->{size} = $vals->{size};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_terms_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{columnFamily});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{columnName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{startWith});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I16) {
        $xfer += $input->readI16(\$self->{size});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_terms_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamily}) {
    $xfer += $output->writeFieldBegin('columnFamily', TType::STRING, 2);
    $xfer += $output->writeString($self->{columnFamily});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnName}) {
    $xfer += $output->writeFieldBegin('columnName', TType::STRING, 3);
    $xfer += $output->writeString($self->{columnName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startWith}) {
    $xfer += $output->writeFieldBegin('startWith', TType::STRING, 4);
    $xfer += $output->writeString($self->{startWith});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{size}) {
    $xfer += $output->writeFieldBegin('size', TType::I16, 5);
    $xfer += $output->writeI16($self->{size});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_terms_result;
use base qw(Class::Accessor);
Blur::Blur_terms_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_terms_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size250 = 0;
          $self->{success} = [];
          my $_etype253 = 0;
          $xfer += $input->readListBegin(\$_etype253, \$_size250);
          for (my $_i254 = 0; $_i254 < $_size250; ++$_i254)
          {
            my $elem255 = undef;
            $xfer += $input->readString(\$elem255);
            push(@{$self->{success}},$elem255);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_terms_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter256 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter256);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_recordFrequency_args;
use base qw(Class::Accessor);
Blur::Blur_recordFrequency_args->mk_accessors( qw( table columnFamily columnName value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{columnFamily} = undef;
  $self->{columnName} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{columnFamily}) {
      $self->{columnFamily} = $vals->{columnFamily};
    }
    if (defined $vals->{columnName}) {
      $self->{columnName} = $vals->{columnName};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_recordFrequency_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{columnFamily});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{columnName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_recordFrequency_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamily}) {
    $xfer += $output->writeFieldBegin('columnFamily', TType::STRING, 2);
    $xfer += $output->writeString($self->{columnFamily});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnName}) {
    $xfer += $output->writeFieldBegin('columnName', TType::STRING, 3);
    $xfer += $output->writeString($self->{columnName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 4);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_recordFrequency_result;
use base qw(Class::Accessor);
Blur::Blur_recordFrequency_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_recordFrequency_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_recordFrequency_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_fetchRow_args;
use base qw(Class::Accessor);
Blur::Blur_fetchRow_args->mk_accessors( qw( table selector ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{selector} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{selector}) {
      $self->{selector} = $vals->{selector};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_fetchRow_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{selector} = new Blur::Selector();
        $xfer += $self->{selector}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_fetchRow_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{selector}) {
    $xfer += $output->writeFieldBegin('selector', TType::STRUCT, 2);
    $xfer += $self->{selector}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_fetchRow_result;
use base qw(Class::Accessor);
Blur::Blur_fetchRow_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_fetchRow_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Blur::FetchResult();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_fetchRow_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_mutate_args;
use base qw(Class::Accessor);
Blur::Blur_mutate_args->mk_accessors( qw( mutation ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutation} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutation}) {
      $self->{mutation} = $vals->{mutation};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_mutate_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{mutation} = new Blur::RowMutation();
        $xfer += $self->{mutation}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_mutate_args');
  if (defined $self->{mutation}) {
    $xfer += $output->writeFieldBegin('mutation', TType::STRUCT, 1);
    $xfer += $self->{mutation}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_mutate_result;
use base qw(Class::Accessor);
Blur::Blur_mutate_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_mutate_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_mutate_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_mutateBatch_args;
use base qw(Class::Accessor);
Blur::Blur_mutateBatch_args->mk_accessors( qw( mutations ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{mutations} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{mutations}) {
      $self->{mutations} = $vals->{mutations};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_mutateBatch_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size257 = 0;
          $self->{mutations} = [];
          my $_etype260 = 0;
          $xfer += $input->readListBegin(\$_etype260, \$_size257);
          for (my $_i261 = 0; $_i261 < $_size257; ++$_i261)
          {
            my $elem262 = undef;
            $elem262 = new Blur::RowMutation();
            $xfer += $elem262->read($input);
            push(@{$self->{mutations}},$elem262);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_mutateBatch_args');
  if (defined $self->{mutations}) {
    $xfer += $output->writeFieldBegin('mutations', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{mutations}}));
      {
        foreach my $iter263 (@{$self->{mutations}}) 
        {
          $xfer += ${iter263}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_mutateBatch_result;
use base qw(Class::Accessor);
Blur::Blur_mutateBatch_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_mutateBatch_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_mutateBatch_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_createTable_args;
use base qw(Class::Accessor);
Blur::Blur_createTable_args->mk_accessors( qw( tableDescriptor ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableDescriptor} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableDescriptor}) {
      $self->{tableDescriptor} = $vals->{tableDescriptor};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_createTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{tableDescriptor} = new Blur::TableDescriptor();
        $xfer += $self->{tableDescriptor}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_createTable_args');
  if (defined $self->{tableDescriptor}) {
    $xfer += $output->writeFieldBegin('tableDescriptor', TType::STRUCT, 1);
    $xfer += $self->{tableDescriptor}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_createTable_result;
use base qw(Class::Accessor);
Blur::Blur_createTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_createTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_createTable_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_enableTable_args;
use base qw(Class::Accessor);
Blur::Blur_enableTable_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_enableTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_enableTable_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_enableTable_result;
use base qw(Class::Accessor);
Blur::Blur_enableTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_enableTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_enableTable_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_disableTable_args;
use base qw(Class::Accessor);
Blur::Blur_disableTable_args->mk_accessors( qw( table ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_disableTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_disableTable_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_disableTable_result;
use base qw(Class::Accessor);
Blur::Blur_disableTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_disableTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_disableTable_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_removeTable_args;
use base qw(Class::Accessor);
Blur::Blur_removeTable_args->mk_accessors( qw( table deleteIndexFiles ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{deleteIndexFiles} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{deleteIndexFiles}) {
      $self->{deleteIndexFiles} = $vals->{deleteIndexFiles};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_removeTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{deleteIndexFiles});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_removeTable_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleteIndexFiles}) {
    $xfer += $output->writeFieldBegin('deleteIndexFiles', TType::BOOL, 2);
    $xfer += $output->writeBool($self->{deleteIndexFiles});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_removeTable_result;
use base qw(Class::Accessor);
Blur::Blur_removeTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_removeTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_removeTable_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_addColumnDefinition_args;
use base qw(Class::Accessor);
Blur::Blur_addColumnDefinition_args->mk_accessors( qw( table columnDefinition ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{columnDefinition} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{columnDefinition}) {
      $self->{columnDefinition} = $vals->{columnDefinition};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_addColumnDefinition_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{columnDefinition} = new Blur::ColumnDefinition();
        $xfer += $self->{columnDefinition}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_addColumnDefinition_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnDefinition}) {
    $xfer += $output->writeFieldBegin('columnDefinition', TType::STRUCT, 2);
    $xfer += $self->{columnDefinition}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_addColumnDefinition_result;
use base qw(Class::Accessor);
Blur::Blur_addColumnDefinition_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_addColumnDefinition_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_addColumnDefinition_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_optimize_args;
use base qw(Class::Accessor);
Blur::Blur_optimize_args->mk_accessors( qw( table numberOfSegmentsPerShard ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{numberOfSegmentsPerShard} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{numberOfSegmentsPerShard}) {
      $self->{numberOfSegmentsPerShard} = $vals->{numberOfSegmentsPerShard};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_optimize_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{numberOfSegmentsPerShard});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_optimize_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{numberOfSegmentsPerShard}) {
    $xfer += $output->writeFieldBegin('numberOfSegmentsPerShard', TType::I32, 2);
    $xfer += $output->writeI32($self->{numberOfSegmentsPerShard});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_optimize_result;
use base qw(Class::Accessor);
Blur::Blur_optimize_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_optimize_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_optimize_result');
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_isInSafeMode_args;
use base qw(Class::Accessor);
Blur::Blur_isInSafeMode_args->mk_accessors( qw( cluster ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{cluster} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{cluster}) {
      $self->{cluster} = $vals->{cluster};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_isInSafeMode_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{cluster});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_isInSafeMode_args');
  if (defined $self->{cluster}) {
    $xfer += $output->writeFieldBegin('cluster', TType::STRING, 1);
    $xfer += $output->writeString($self->{cluster});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_isInSafeMode_result;
use base qw(Class::Accessor);
Blur::Blur_isInSafeMode_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_isInSafeMode_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_isInSafeMode_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_configuration_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_configuration_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_configuration_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_configuration_result;
use base qw(Class::Accessor);
Blur::Blur_configuration_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_configuration_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size264 = 0;
          $self->{success} = {};
          my $_ktype265 = 0;
          my $_vtype266 = 0;
          $xfer += $input->readMapBegin(\$_ktype265, \$_vtype266, \$_size264);
          for (my $_i268 = 0; $_i268 < $_size264; ++$_i268)
          {
            my $key269 = '';
            my $val270 = '';
            $xfer += $input->readString(\$key269);
            $xfer += $input->readString(\$val270);
            $self->{success}->{$key269} = $val270;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_configuration_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter271,$viter272) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter271);
          $xfer += $output->writeString($viter272);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_metrics_args;
use base qw(Class::Accessor);
Blur::Blur_metrics_args->mk_accessors( qw( metrics ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{metrics} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{metrics}) {
      $self->{metrics} = $vals->{metrics};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_metrics_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::SET) {
        {
          my $_size273 = 0;
          $self->{metrics} = {};
          my $_etype276 = 0;
          $xfer += $input->readSetBegin(\$_etype276, \$_size273);
          for (my $_i277 = 0; $_i277 < $_size273; ++$_i277)
          {
            my $elem278 = undef;
            $xfer += $input->readString(\$elem278);
            $self->{metrics}->{$elem278} = 1;
          }
          $xfer += $input->readSetEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_metrics_args');
  if (defined $self->{metrics}) {
    $xfer += $output->writeFieldBegin('metrics', TType::SET, 1);
    {
      $xfer += $output->writeSetBegin(TType::STRING, scalar(@{$self->{metrics}}));
      {
        foreach my $iter279 (@{$self->{metrics}})
        {
          $xfer += $output->writeString($iter279);
        }
      }
      $xfer += $output->writeSetEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::Blur_metrics_result;
use base qw(Class::Accessor);
Blur::Blur_metrics_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{ex} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ex}) {
      $self->{ex} = $vals->{ex};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Blur_metrics_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size280 = 0;
          $self->{success} = {};
          my $_ktype281 = 0;
          my $_vtype282 = 0;
          $xfer += $input->readMapBegin(\$_ktype281, \$_vtype282, \$_size280);
          for (my $_i284 = 0; $_i284 < $_size280; ++$_i284)
          {
            my $key285 = '';
            my $val286 = new Blur::Metric();
            $xfer += $input->readString(\$key285);
            $val286 = new Blur::Metric();
            $xfer += $val286->read($input);
            $self->{success}->{$key285} = $val286;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ex} = new Blur::BlurException();
        $xfer += $self->{ex}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Blur_metrics_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter287,$viter288) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter287);
          $xfer += ${viter288}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ex}) {
    $xfer += $output->writeFieldBegin('ex', TType::STRUCT, 1);
    $xfer += $self->{ex}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Blur::BlurIf;

use strict;


sub shardClusterList{
  my $self = shift;

  die 'implement interface';
}

sub shardServerList{
  my $self = shift;
  my $cluster = shift;

  die 'implement interface';
}

sub controllerServerList{
  my $self = shift;

  die 'implement interface';
}

sub shardServerLayout{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub shardServerLayoutState{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub tableList{
  my $self = shift;

  die 'implement interface';
}

sub tableListByCluster{
  my $self = shift;
  my $cluster = shift;

  die 'implement interface';
}

sub describe{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub query{
  my $self = shift;
  my $table = shift;
  my $blurQuery = shift;

  die 'implement interface';
}

sub parseQuery{
  my $self = shift;
  my $table = shift;
  my $simpleQuery = shift;

  die 'implement interface';
}

sub cancelQuery{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

  die 'implement interface';
}

sub currentQueries{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub queryStatusIdList{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub queryStatusById{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

  die 'implement interface';
}

sub schema{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub getTableStats{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub tableStats{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub terms{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $startWith = shift;
  my $size = shift;

  die 'implement interface';
}

sub recordFrequency{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $value = shift;

  die 'implement interface';
}

sub fetchRow{
  my $self = shift;
  my $table = shift;
  my $selector = shift;

  die 'implement interface';
}

sub mutate{
  my $self = shift;
  my $mutation = shift;

  die 'implement interface';
}

sub mutateBatch{
  my $self = shift;
  my $mutations = shift;

  die 'implement interface';
}

sub createTable{
  my $self = shift;
  my $tableDescriptor = shift;

  die 'implement interface';
}

sub enableTable{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub disableTable{
  my $self = shift;
  my $table = shift;

  die 'implement interface';
}

sub removeTable{
  my $self = shift;
  my $table = shift;
  my $deleteIndexFiles = shift;

  die 'implement interface';
}

sub addColumnDefinition{
  my $self = shift;
  my $table = shift;
  my $columnDefinition = shift;

  die 'implement interface';
}

sub optimize{
  my $self = shift;
  my $table = shift;
  my $numberOfSegmentsPerShard = shift;

  die 'implement interface';
}

sub isInSafeMode{
  my $self = shift;
  my $cluster = shift;

  die 'implement interface';
}

sub configuration{
  my $self = shift;

  die 'implement interface';
}

sub metrics{
  my $self = shift;
  my $metrics = shift;

  die 'implement interface';
}

package Blur::BlurRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub shardClusterList{
  my ($self, $request) = @_;

  return $self->{impl}->shardClusterList();
}

sub shardServerList{
  my ($self, $request) = @_;

  my $cluster = ($request->{'cluster'}) ? $request->{'cluster'} : undef;
  return $self->{impl}->shardServerList($cluster);
}

sub controllerServerList{
  my ($self, $request) = @_;

  return $self->{impl}->controllerServerList();
}

sub shardServerLayout{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->shardServerLayout($table);
}

sub shardServerLayoutState{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->shardServerLayoutState($table);
}

sub tableList{
  my ($self, $request) = @_;

  return $self->{impl}->tableList();
}

sub tableListByCluster{
  my ($self, $request) = @_;

  my $cluster = ($request->{'cluster'}) ? $request->{'cluster'} : undef;
  return $self->{impl}->tableListByCluster($cluster);
}

sub describe{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->describe($table);
}

sub query{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $blurQuery = ($request->{'blurQuery'}) ? $request->{'blurQuery'} : undef;
  return $self->{impl}->query($table, $blurQuery);
}

sub parseQuery{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $simpleQuery = ($request->{'simpleQuery'}) ? $request->{'simpleQuery'} : undef;
  return $self->{impl}->parseQuery($table, $simpleQuery);
}

sub cancelQuery{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $uuid = ($request->{'uuid'}) ? $request->{'uuid'} : undef;
  return $self->{impl}->cancelQuery($table, $uuid);
}

sub currentQueries{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->currentQueries($table);
}

sub queryStatusIdList{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->queryStatusIdList($table);
}

sub queryStatusById{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $uuid = ($request->{'uuid'}) ? $request->{'uuid'} : undef;
  return $self->{impl}->queryStatusById($table, $uuid);
}

sub schema{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->schema($table);
}

sub getTableStats{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->getTableStats($table);
}

sub tableStats{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->tableStats($table);
}

sub terms{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $columnFamily = ($request->{'columnFamily'}) ? $request->{'columnFamily'} : undef;
  my $columnName = ($request->{'columnName'}) ? $request->{'columnName'} : undef;
  my $startWith = ($request->{'startWith'}) ? $request->{'startWith'} : undef;
  my $size = ($request->{'size'}) ? $request->{'size'} : undef;
  return $self->{impl}->terms($table, $columnFamily, $columnName, $startWith, $size);
}

sub recordFrequency{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $columnFamily = ($request->{'columnFamily'}) ? $request->{'columnFamily'} : undef;
  my $columnName = ($request->{'columnName'}) ? $request->{'columnName'} : undef;
  my $value = ($request->{'value'}) ? $request->{'value'} : undef;
  return $self->{impl}->recordFrequency($table, $columnFamily, $columnName, $value);
}

sub fetchRow{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $selector = ($request->{'selector'}) ? $request->{'selector'} : undef;
  return $self->{impl}->fetchRow($table, $selector);
}

sub mutate{
  my ($self, $request) = @_;

  my $mutation = ($request->{'mutation'}) ? $request->{'mutation'} : undef;
  return $self->{impl}->mutate($mutation);
}

sub mutateBatch{
  my ($self, $request) = @_;

  my $mutations = ($request->{'mutations'}) ? $request->{'mutations'} : undef;
  return $self->{impl}->mutateBatch($mutations);
}

sub createTable{
  my ($self, $request) = @_;

  my $tableDescriptor = ($request->{'tableDescriptor'}) ? $request->{'tableDescriptor'} : undef;
  return $self->{impl}->createTable($tableDescriptor);
}

sub enableTable{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->enableTable($table);
}

sub disableTable{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  return $self->{impl}->disableTable($table);
}

sub removeTable{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $deleteIndexFiles = ($request->{'deleteIndexFiles'}) ? $request->{'deleteIndexFiles'} : undef;
  return $self->{impl}->removeTable($table, $deleteIndexFiles);
}

sub addColumnDefinition{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $columnDefinition = ($request->{'columnDefinition'}) ? $request->{'columnDefinition'} : undef;
  return $self->{impl}->addColumnDefinition($table, $columnDefinition);
}

sub optimize{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $numberOfSegmentsPerShard = ($request->{'numberOfSegmentsPerShard'}) ? $request->{'numberOfSegmentsPerShard'} : undef;
  return $self->{impl}->optimize($table, $numberOfSegmentsPerShard);
}

sub isInSafeMode{
  my ($self, $request) = @_;

  my $cluster = ($request->{'cluster'}) ? $request->{'cluster'} : undef;
  return $self->{impl}->isInSafeMode($cluster);
}

sub configuration{
  my ($self, $request) = @_;

  return $self->{impl}->configuration();
}

sub metrics{
  my ($self, $request) = @_;

  my $metrics = ($request->{'metrics'}) ? $request->{'metrics'} : undef;
  return $self->{impl}->metrics($metrics);
}

package Blur::BlurClient;


use base qw(Blur::BlurIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub shardClusterList{
  my $self = shift;

    $self->send_shardClusterList();
  return $self->recv_shardClusterList();
}

sub send_shardClusterList{
  my $self = shift;

  $self->{output}->writeMessageBegin('shardClusterList', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_shardClusterList_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shardClusterList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_shardClusterList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "shardClusterList failed: unknown result";
}
sub shardServerList{
  my $self = shift;
  my $cluster = shift;

    $self->send_shardServerList($cluster);
  return $self->recv_shardServerList();
}

sub send_shardServerList{
  my $self = shift;
  my $cluster = shift;

  $self->{output}->writeMessageBegin('shardServerList', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_shardServerList_args();
  $args->{cluster} = $cluster;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shardServerList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_shardServerList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "shardServerList failed: unknown result";
}
sub controllerServerList{
  my $self = shift;

    $self->send_controllerServerList();
  return $self->recv_controllerServerList();
}

sub send_controllerServerList{
  my $self = shift;

  $self->{output}->writeMessageBegin('controllerServerList', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_controllerServerList_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_controllerServerList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_controllerServerList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "controllerServerList failed: unknown result";
}
sub shardServerLayout{
  my $self = shift;
  my $table = shift;

    $self->send_shardServerLayout($table);
  return $self->recv_shardServerLayout();
}

sub send_shardServerLayout{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('shardServerLayout', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_shardServerLayout_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shardServerLayout{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_shardServerLayout_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "shardServerLayout failed: unknown result";
}
sub shardServerLayoutState{
  my $self = shift;
  my $table = shift;

    $self->send_shardServerLayoutState($table);
  return $self->recv_shardServerLayoutState();
}

sub send_shardServerLayoutState{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('shardServerLayoutState', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_shardServerLayoutState_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_shardServerLayoutState{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_shardServerLayoutState_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "shardServerLayoutState failed: unknown result";
}
sub tableList{
  my $self = shift;

    $self->send_tableList();
  return $self->recv_tableList();
}

sub send_tableList{
  my $self = shift;

  $self->{output}->writeMessageBegin('tableList', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_tableList_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_tableList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_tableList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "tableList failed: unknown result";
}
sub tableListByCluster{
  my $self = shift;
  my $cluster = shift;

    $self->send_tableListByCluster($cluster);
  return $self->recv_tableListByCluster();
}

sub send_tableListByCluster{
  my $self = shift;
  my $cluster = shift;

  $self->{output}->writeMessageBegin('tableListByCluster', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_tableListByCluster_args();
  $args->{cluster} = $cluster;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_tableListByCluster{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_tableListByCluster_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "tableListByCluster failed: unknown result";
}
sub describe{
  my $self = shift;
  my $table = shift;

    $self->send_describe($table);
  return $self->recv_describe();
}

sub send_describe{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('describe', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_describe_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_describe{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_describe_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "describe failed: unknown result";
}
sub query{
  my $self = shift;
  my $table = shift;
  my $blurQuery = shift;

    $self->send_query($table, $blurQuery);
  return $self->recv_query();
}

sub send_query{
  my $self = shift;
  my $table = shift;
  my $blurQuery = shift;

  $self->{output}->writeMessageBegin('query', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_query_args();
  $args->{table} = $table;
  $args->{blurQuery} = $blurQuery;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_query{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_query_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "query failed: unknown result";
}
sub parseQuery{
  my $self = shift;
  my $table = shift;
  my $simpleQuery = shift;

    $self->send_parseQuery($table, $simpleQuery);
  return $self->recv_parseQuery();
}

sub send_parseQuery{
  my $self = shift;
  my $table = shift;
  my $simpleQuery = shift;

  $self->{output}->writeMessageBegin('parseQuery', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_parseQuery_args();
  $args->{table} = $table;
  $args->{simpleQuery} = $simpleQuery;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_parseQuery{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_parseQuery_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "parseQuery failed: unknown result";
}
sub cancelQuery{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

    $self->send_cancelQuery($table, $uuid);
  $self->recv_cancelQuery();
}

sub send_cancelQuery{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

  $self->{output}->writeMessageBegin('cancelQuery', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_cancelQuery_args();
  $args->{table} = $table;
  $args->{uuid} = $uuid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_cancelQuery{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_cancelQuery_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub currentQueries{
  my $self = shift;
  my $table = shift;

    $self->send_currentQueries($table);
  return $self->recv_currentQueries();
}

sub send_currentQueries{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('currentQueries', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_currentQueries_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_currentQueries{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_currentQueries_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "currentQueries failed: unknown result";
}
sub queryStatusIdList{
  my $self = shift;
  my $table = shift;

    $self->send_queryStatusIdList($table);
  return $self->recv_queryStatusIdList();
}

sub send_queryStatusIdList{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('queryStatusIdList', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_queryStatusIdList_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_queryStatusIdList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_queryStatusIdList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "queryStatusIdList failed: unknown result";
}
sub queryStatusById{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

    $self->send_queryStatusById($table, $uuid);
  return $self->recv_queryStatusById();
}

sub send_queryStatusById{
  my $self = shift;
  my $table = shift;
  my $uuid = shift;

  $self->{output}->writeMessageBegin('queryStatusById', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_queryStatusById_args();
  $args->{table} = $table;
  $args->{uuid} = $uuid;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_queryStatusById{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_queryStatusById_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "queryStatusById failed: unknown result";
}
sub schema{
  my $self = shift;
  my $table = shift;

    $self->send_schema($table);
  return $self->recv_schema();
}

sub send_schema{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('schema', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_schema_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_schema{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_schema_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "schema failed: unknown result";
}
sub getTableStats{
  my $self = shift;
  my $table = shift;

    $self->send_getTableStats($table);
  return $self->recv_getTableStats();
}

sub send_getTableStats{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('getTableStats', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_getTableStats_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getTableStats{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_getTableStats_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "getTableStats failed: unknown result";
}
sub tableStats{
  my $self = shift;
  my $table = shift;

    $self->send_tableStats($table);
  return $self->recv_tableStats();
}

sub send_tableStats{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('tableStats', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_tableStats_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_tableStats{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_tableStats_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "tableStats failed: unknown result";
}
sub terms{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $startWith = shift;
  my $size = shift;

    $self->send_terms($table, $columnFamily, $columnName, $startWith, $size);
  return $self->recv_terms();
}

sub send_terms{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $startWith = shift;
  my $size = shift;

  $self->{output}->writeMessageBegin('terms', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_terms_args();
  $args->{table} = $table;
  $args->{columnFamily} = $columnFamily;
  $args->{columnName} = $columnName;
  $args->{startWith} = $startWith;
  $args->{size} = $size;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_terms{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_terms_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "terms failed: unknown result";
}
sub recordFrequency{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $value = shift;

    $self->send_recordFrequency($table, $columnFamily, $columnName, $value);
  return $self->recv_recordFrequency();
}

sub send_recordFrequency{
  my $self = shift;
  my $table = shift;
  my $columnFamily = shift;
  my $columnName = shift;
  my $value = shift;

  $self->{output}->writeMessageBegin('recordFrequency', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_recordFrequency_args();
  $args->{table} = $table;
  $args->{columnFamily} = $columnFamily;
  $args->{columnName} = $columnName;
  $args->{value} = $value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_recordFrequency{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_recordFrequency_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "recordFrequency failed: unknown result";
}
sub fetchRow{
  my $self = shift;
  my $table = shift;
  my $selector = shift;

    $self->send_fetchRow($table, $selector);
  return $self->recv_fetchRow();
}

sub send_fetchRow{
  my $self = shift;
  my $table = shift;
  my $selector = shift;

  $self->{output}->writeMessageBegin('fetchRow', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_fetchRow_args();
  $args->{table} = $table;
  $args->{selector} = $selector;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_fetchRow{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_fetchRow_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "fetchRow failed: unknown result";
}
sub mutate{
  my $self = shift;
  my $mutation = shift;

    $self->send_mutate($mutation);
  $self->recv_mutate();
}

sub send_mutate{
  my $self = shift;
  my $mutation = shift;

  $self->{output}->writeMessageBegin('mutate', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_mutate_args();
  $args->{mutation} = $mutation;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutate{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_mutate_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub mutateBatch{
  my $self = shift;
  my $mutations = shift;

    $self->send_mutateBatch($mutations);
  $self->recv_mutateBatch();
}

sub send_mutateBatch{
  my $self = shift;
  my $mutations = shift;

  $self->{output}->writeMessageBegin('mutateBatch', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_mutateBatch_args();
  $args->{mutations} = $mutations;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutateBatch{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_mutateBatch_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub createTable{
  my $self = shift;
  my $tableDescriptor = shift;

    $self->send_createTable($tableDescriptor);
  $self->recv_createTable();
}

sub send_createTable{
  my $self = shift;
  my $tableDescriptor = shift;

  $self->{output}->writeMessageBegin('createTable', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_createTable_args();
  $args->{tableDescriptor} = $tableDescriptor;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_createTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_createTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub enableTable{
  my $self = shift;
  my $table = shift;

    $self->send_enableTable($table);
  $self->recv_enableTable();
}

sub send_enableTable{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('enableTable', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_enableTable_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_enableTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_enableTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub disableTable{
  my $self = shift;
  my $table = shift;

    $self->send_disableTable($table);
  $self->recv_disableTable();
}

sub send_disableTable{
  my $self = shift;
  my $table = shift;

  $self->{output}->writeMessageBegin('disableTable', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_disableTable_args();
  $args->{table} = $table;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_disableTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_disableTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub removeTable{
  my $self = shift;
  my $table = shift;
  my $deleteIndexFiles = shift;

    $self->send_removeTable($table, $deleteIndexFiles);
  $self->recv_removeTable();
}

sub send_removeTable{
  my $self = shift;
  my $table = shift;
  my $deleteIndexFiles = shift;

  $self->{output}->writeMessageBegin('removeTable', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_removeTable_args();
  $args->{table} = $table;
  $args->{deleteIndexFiles} = $deleteIndexFiles;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_removeTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_removeTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub addColumnDefinition{
  my $self = shift;
  my $table = shift;
  my $columnDefinition = shift;

    $self->send_addColumnDefinition($table, $columnDefinition);
  return $self->recv_addColumnDefinition();
}

sub send_addColumnDefinition{
  my $self = shift;
  my $table = shift;
  my $columnDefinition = shift;

  $self->{output}->writeMessageBegin('addColumnDefinition', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_addColumnDefinition_args();
  $args->{table} = $table;
  $args->{columnDefinition} = $columnDefinition;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_addColumnDefinition{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_addColumnDefinition_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "addColumnDefinition failed: unknown result";
}
sub optimize{
  my $self = shift;
  my $table = shift;
  my $numberOfSegmentsPerShard = shift;

    $self->send_optimize($table, $numberOfSegmentsPerShard);
  $self->recv_optimize();
}

sub send_optimize{
  my $self = shift;
  my $table = shift;
  my $numberOfSegmentsPerShard = shift;

  $self->{output}->writeMessageBegin('optimize', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_optimize_args();
  $args->{table} = $table;
  $args->{numberOfSegmentsPerShard} = $numberOfSegmentsPerShard;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_optimize{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_optimize_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{ex}) {
    die $result->{ex};
  }
  return;
}
sub isInSafeMode{
  my $self = shift;
  my $cluster = shift;

    $self->send_isInSafeMode($cluster);
  return $self->recv_isInSafeMode();
}

sub send_isInSafeMode{
  my $self = shift;
  my $cluster = shift;

  $self->{output}->writeMessageBegin('isInSafeMode', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_isInSafeMode_args();
  $args->{cluster} = $cluster;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_isInSafeMode{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_isInSafeMode_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "isInSafeMode failed: unknown result";
}
sub configuration{
  my $self = shift;

    $self->send_configuration();
  return $self->recv_configuration();
}

sub send_configuration{
  my $self = shift;

  $self->{output}->writeMessageBegin('configuration', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_configuration_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_configuration{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_configuration_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "configuration failed: unknown result";
}
sub metrics{
  my $self = shift;
  my $metrics = shift;

    $self->send_metrics($metrics);
  return $self->recv_metrics();
}

sub send_metrics{
  my $self = shift;
  my $metrics = shift;

  $self->{output}->writeMessageBegin('metrics', TMessageType::CALL, $self->{seqid});
  my $args = new Blur::Blur_metrics_args();
  $args->{metrics} = $metrics;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_metrics{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Blur::Blur_metrics_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ex}) {
    die $result->{ex};
  }
  die "metrics failed: unknown result";
}
package Blur::BlurProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_shardClusterList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_shardClusterList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_shardClusterList_result();
    eval {
      $result->{success} = $self->{handler}->shardClusterList();
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('shardClusterList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shardServerList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_shardServerList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_shardServerList_result();
    eval {
      $result->{success} = $self->{handler}->shardServerList($args->cluster);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('shardServerList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_controllerServerList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_controllerServerList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_controllerServerList_result();
    eval {
      $result->{success} = $self->{handler}->controllerServerList();
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('controllerServerList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shardServerLayout {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_shardServerLayout_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_shardServerLayout_result();
    eval {
      $result->{success} = $self->{handler}->shardServerLayout($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('shardServerLayout', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_shardServerLayoutState {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_shardServerLayoutState_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_shardServerLayoutState_result();
    eval {
      $result->{success} = $self->{handler}->shardServerLayoutState($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('shardServerLayoutState', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_tableList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_tableList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_tableList_result();
    eval {
      $result->{success} = $self->{handler}->tableList();
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('tableList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_tableListByCluster {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_tableListByCluster_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_tableListByCluster_result();
    eval {
      $result->{success} = $self->{handler}->tableListByCluster($args->cluster);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('tableListByCluster', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_describe {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_describe_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_describe_result();
    eval {
      $result->{success} = $self->{handler}->describe($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('describe', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_query {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_query_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_query_result();
    eval {
      $result->{success} = $self->{handler}->query($args->table, $args->blurQuery);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('query', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_parseQuery {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_parseQuery_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_parseQuery_result();
    eval {
      $result->{success} = $self->{handler}->parseQuery($args->table, $args->simpleQuery);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('parseQuery', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_cancelQuery {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_cancelQuery_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_cancelQuery_result();
    eval {
      $self->{handler}->cancelQuery($args->table, $args->uuid);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('cancelQuery', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_currentQueries {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_currentQueries_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_currentQueries_result();
    eval {
      $result->{success} = $self->{handler}->currentQueries($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('currentQueries', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_queryStatusIdList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_queryStatusIdList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_queryStatusIdList_result();
    eval {
      $result->{success} = $self->{handler}->queryStatusIdList($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('queryStatusIdList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_queryStatusById {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_queryStatusById_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_queryStatusById_result();
    eval {
      $result->{success} = $self->{handler}->queryStatusById($args->table, $args->uuid);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('queryStatusById', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_schema {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_schema_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_schema_result();
    eval {
      $result->{success} = $self->{handler}->schema($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('schema', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getTableStats {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_getTableStats_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_getTableStats_result();
    eval {
      $result->{success} = $self->{handler}->getTableStats($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('getTableStats', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_tableStats {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_tableStats_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_tableStats_result();
    eval {
      $result->{success} = $self->{handler}->tableStats($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('tableStats', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_terms {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_terms_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_terms_result();
    eval {
      $result->{success} = $self->{handler}->terms($args->table, $args->columnFamily, $args->columnName, $args->startWith, $args->size);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('terms', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_recordFrequency {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_recordFrequency_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_recordFrequency_result();
    eval {
      $result->{success} = $self->{handler}->recordFrequency($args->table, $args->columnFamily, $args->columnName, $args->value);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('recordFrequency', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_fetchRow {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_fetchRow_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_fetchRow_result();
    eval {
      $result->{success} = $self->{handler}->fetchRow($args->table, $args->selector);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('fetchRow', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutate {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_mutate_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_mutate_result();
    eval {
      $self->{handler}->mutate($args->mutation);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('mutate', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutateBatch {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_mutateBatch_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_mutateBatch_result();
    eval {
      $self->{handler}->mutateBatch($args->mutations);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('mutateBatch', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_createTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_createTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_createTable_result();
    eval {
      $self->{handler}->createTable($args->tableDescriptor);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('createTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_enableTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_enableTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_enableTable_result();
    eval {
      $self->{handler}->enableTable($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('enableTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_disableTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_disableTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_disableTable_result();
    eval {
      $self->{handler}->disableTable($args->table);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('disableTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_removeTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_removeTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_removeTable_result();
    eval {
      $self->{handler}->removeTable($args->table, $args->deleteIndexFiles);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('removeTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_addColumnDefinition {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_addColumnDefinition_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_addColumnDefinition_result();
    eval {
      $result->{success} = $self->{handler}->addColumnDefinition($args->table, $args->columnDefinition);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('addColumnDefinition', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_optimize {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_optimize_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_optimize_result();
    eval {
      $self->{handler}->optimize($args->table, $args->numberOfSegmentsPerShard);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('optimize', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_isInSafeMode {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_isInSafeMode_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_isInSafeMode_result();
    eval {
      $result->{success} = $self->{handler}->isInSafeMode($args->cluster);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('isInSafeMode', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_configuration {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_configuration_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_configuration_result();
    eval {
      $result->{success} = $self->{handler}->configuration();
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('configuration', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_metrics {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Blur::Blur_metrics_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Blur::Blur_metrics_result();
    eval {
      $result->{success} = $self->{handler}->metrics($args->metrics);
    }; if( UNIVERSAL::isa($@,'Blur::BlurException') ){ 
      $result->{ex} = $@;
    }
    $output->writeMessageBegin('metrics', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
