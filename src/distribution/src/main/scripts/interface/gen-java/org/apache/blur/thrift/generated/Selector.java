/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package org.apache.blur.thrift.generated;

/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



import org.apache.thrift.scheme.IScheme;
import org.apache.thrift.scheme.SchemeFactory;
import org.apache.thrift.scheme.StandardScheme;

import org.apache.thrift.scheme.TupleScheme;
import org.apache.thrift.protocol.TTupleProtocol;
import org.apache.thrift.protocol.TProtocolException;
import org.apache.thrift.EncodingUtils;
import org.apache.thrift.TException;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Select carries the request for information to be retrieved from the stored columns.
 */
public class Selector implements org.apache.thrift.TBase<Selector, Selector._Fields>, java.io.Serializable, Cloneable {
  private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("Selector");

  private static final org.apache.thrift.protocol.TField RECORD_ONLY_FIELD_DESC = new org.apache.thrift.protocol.TField("recordOnly", org.apache.thrift.protocol.TType.BOOL, (short)1);
  private static final org.apache.thrift.protocol.TField LOCATION_ID_FIELD_DESC = new org.apache.thrift.protocol.TField("locationId", org.apache.thrift.protocol.TType.STRING, (short)2);
  private static final org.apache.thrift.protocol.TField ROW_ID_FIELD_DESC = new org.apache.thrift.protocol.TField("rowId", org.apache.thrift.protocol.TType.STRING, (short)3);
  private static final org.apache.thrift.protocol.TField RECORD_ID_FIELD_DESC = new org.apache.thrift.protocol.TField("recordId", org.apache.thrift.protocol.TType.STRING, (short)4);
  private static final org.apache.thrift.protocol.TField COLUMN_FAMILIES_TO_FETCH_FIELD_DESC = new org.apache.thrift.protocol.TField("columnFamiliesToFetch", org.apache.thrift.protocol.TType.SET, (short)5);
  private static final org.apache.thrift.protocol.TField COLUMNS_TO_FETCH_FIELD_DESC = new org.apache.thrift.protocol.TField("columnsToFetch", org.apache.thrift.protocol.TType.MAP, (short)6);
  private static final org.apache.thrift.protocol.TField ALLOW_STALE_DATA_FIELD_DESC = new org.apache.thrift.protocol.TField("allowStaleData", org.apache.thrift.protocol.TType.BOOL, (short)7);

  private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
  static {
    schemes.put(StandardScheme.class, new SelectorStandardSchemeFactory());
    schemes.put(TupleScheme.class, new SelectorTupleSchemeFactory());
  }

  /**
   * Fetch the Record only, not the entire Row.
   */
  public boolean recordOnly; // required
  /**
   * The location id of the Record or Row to be fetched.
   */
  public String locationId; // required
  /**
   * The row id of the Row to be fetched, not to be used with location id.
   */
  public String rowId; // required
  /**
   * The record id of the Record to be fetched, not to be used with location id.  However the row id needs to be provided to locate the correct Row with the requested Record.
   */
  public String recordId; // required
  /**
   * The column families to fetch.  If null, fetch all.  If empty, fetch none.
   */
  public Set<String> columnFamiliesToFetch; // required
  /**
   * The columns in the families to fetch.  If null, fetch all.  If empty, fetch none.
   */
  public Map<String,Set<String>> columnsToFetch; // required
  /**
   * @deprecated This value is no longer used.  This allows the fetch to see the most current data that has been added to the table.
   */
  public boolean allowStaleData; // required

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements org.apache.thrift.TFieldIdEnum {
    /**
     * Fetch the Record only, not the entire Row.
     */
    RECORD_ONLY((short)1, "recordOnly"),
    /**
     * The location id of the Record or Row to be fetched.
     */
    LOCATION_ID((short)2, "locationId"),
    /**
     * The row id of the Row to be fetched, not to be used with location id.
     */
    ROW_ID((short)3, "rowId"),
    /**
     * The record id of the Record to be fetched, not to be used with location id.  However the row id needs to be provided to locate the correct Row with the requested Record.
     */
    RECORD_ID((short)4, "recordId"),
    /**
     * The column families to fetch.  If null, fetch all.  If empty, fetch none.
     */
    COLUMN_FAMILIES_TO_FETCH((short)5, "columnFamiliesToFetch"),
    /**
     * The columns in the families to fetch.  If null, fetch all.  If empty, fetch none.
     */
    COLUMNS_TO_FETCH((short)6, "columnsToFetch"),
    /**
     * @deprecated This value is no longer used.  This allows the fetch to see the most current data that has been added to the table.
     */
    ALLOW_STALE_DATA((short)7, "allowStaleData");

    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 1: // RECORD_ONLY
          return RECORD_ONLY;
        case 2: // LOCATION_ID
          return LOCATION_ID;
        case 3: // ROW_ID
          return ROW_ID;
        case 4: // RECORD_ID
          return RECORD_ID;
        case 5: // COLUMN_FAMILIES_TO_FETCH
          return COLUMN_FAMILIES_TO_FETCH;
        case 6: // COLUMNS_TO_FETCH
          return COLUMNS_TO_FETCH;
        case 7: // ALLOW_STALE_DATA
          return ALLOW_STALE_DATA;
        default:
          return null;
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }

    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }

    private final short _thriftId;
    private final String _fieldName;

    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }

    public short getThriftFieldId() {
      return _thriftId;
    }

    public String getFieldName() {
      return _fieldName;
    }
  }

  // isset id assignments
  private static final int __RECORDONLY_ISSET_ID = 0;
  private static final int __ALLOWSTALEDATA_ISSET_ID = 1;
  private byte __isset_bitfield = 0;
  public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
  static {
    Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.RECORD_ONLY, new org.apache.thrift.meta_data.FieldMetaData("recordOnly", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
    tmpMap.put(_Fields.LOCATION_ID, new org.apache.thrift.meta_data.FieldMetaData("locationId", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
    tmpMap.put(_Fields.ROW_ID, new org.apache.thrift.meta_data.FieldMetaData("rowId", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
    tmpMap.put(_Fields.RECORD_ID, new org.apache.thrift.meta_data.FieldMetaData("recordId", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
    tmpMap.put(_Fields.COLUMN_FAMILIES_TO_FETCH, new org.apache.thrift.meta_data.FieldMetaData("columnFamiliesToFetch", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.SetMetaData(org.apache.thrift.protocol.TType.SET, 
            new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING))));
    tmpMap.put(_Fields.COLUMNS_TO_FETCH, new org.apache.thrift.meta_data.FieldMetaData("columnsToFetch", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.MapMetaData(org.apache.thrift.protocol.TType.MAP, 
            new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING), 
            new org.apache.thrift.meta_data.SetMetaData(org.apache.thrift.protocol.TType.SET, 
                new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)))));
    tmpMap.put(_Fields.ALLOW_STALE_DATA, new org.apache.thrift.meta_data.FieldMetaData("allowStaleData", org.apache.thrift.TFieldRequirementType.DEFAULT, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.BOOL)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(Selector.class, metaDataMap);
  }

  public Selector() {
  }

  public Selector(
    boolean recordOnly,
    String locationId,
    String rowId,
    String recordId,
    Set<String> columnFamiliesToFetch,
    Map<String,Set<String>> columnsToFetch,
    boolean allowStaleData)
  {
    this();
    this.recordOnly = recordOnly;
    setRecordOnlyIsSet(true);
    this.locationId = locationId;
    this.rowId = rowId;
    this.recordId = recordId;
    this.columnFamiliesToFetch = columnFamiliesToFetch;
    this.columnsToFetch = columnsToFetch;
    this.allowStaleData = allowStaleData;
    setAllowStaleDataIsSet(true);
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public Selector(Selector other) {
    __isset_bitfield = other.__isset_bitfield;
    this.recordOnly = other.recordOnly;
    if (other.isSetLocationId()) {
      this.locationId = other.locationId;
    }
    if (other.isSetRowId()) {
      this.rowId = other.rowId;
    }
    if (other.isSetRecordId()) {
      this.recordId = other.recordId;
    }
    if (other.isSetColumnFamiliesToFetch()) {
      Set<String> __this__columnFamiliesToFetch = new HashSet<String>();
      for (String other_element : other.columnFamiliesToFetch) {
        __this__columnFamiliesToFetch.add(other_element);
      }
      this.columnFamiliesToFetch = __this__columnFamiliesToFetch;
    }
    if (other.isSetColumnsToFetch()) {
      Map<String,Set<String>> __this__columnsToFetch = new HashMap<String,Set<String>>();
      for (Map.Entry<String, Set<String>> other_element : other.columnsToFetch.entrySet()) {

        String other_element_key = other_element.getKey();
        Set<String> other_element_value = other_element.getValue();

        String __this__columnsToFetch_copy_key = other_element_key;

        Set<String> __this__columnsToFetch_copy_value = new HashSet<String>();
        for (String other_element_value_element : other_element_value) {
          __this__columnsToFetch_copy_value.add(other_element_value_element);
        }

        __this__columnsToFetch.put(__this__columnsToFetch_copy_key, __this__columnsToFetch_copy_value);
      }
      this.columnsToFetch = __this__columnsToFetch;
    }
    this.allowStaleData = other.allowStaleData;
  }

  public Selector deepCopy() {
    return new Selector(this);
  }

  @Override
  public void clear() {
    setRecordOnlyIsSet(false);
    this.recordOnly = false;
    this.locationId = null;
    this.rowId = null;
    this.recordId = null;
    this.columnFamiliesToFetch = null;
    this.columnsToFetch = null;
    setAllowStaleDataIsSet(false);
    this.allowStaleData = false;
  }

  /**
   * Fetch the Record only, not the entire Row.
   */
  public boolean isRecordOnly() {
    return this.recordOnly;
  }

  /**
   * Fetch the Record only, not the entire Row.
   */
  public Selector setRecordOnly(boolean recordOnly) {
    this.recordOnly = recordOnly;
    setRecordOnlyIsSet(true);
    return this;
  }

  public void unsetRecordOnly() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __RECORDONLY_ISSET_ID);
  }

  /** Returns true if field recordOnly is set (has been assigned a value) and false otherwise */
  public boolean isSetRecordOnly() {
    return EncodingUtils.testBit(__isset_bitfield, __RECORDONLY_ISSET_ID);
  }

  public void setRecordOnlyIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __RECORDONLY_ISSET_ID, value);
  }

  /**
   * The location id of the Record or Row to be fetched.
   */
  public String getLocationId() {
    return this.locationId;
  }

  /**
   * The location id of the Record or Row to be fetched.
   */
  public Selector setLocationId(String locationId) {
    this.locationId = locationId;
    return this;
  }

  public void unsetLocationId() {
    this.locationId = null;
  }

  /** Returns true if field locationId is set (has been assigned a value) and false otherwise */
  public boolean isSetLocationId() {
    return this.locationId != null;
  }

  public void setLocationIdIsSet(boolean value) {
    if (!value) {
      this.locationId = null;
    }
  }

  /**
   * The row id of the Row to be fetched, not to be used with location id.
   */
  public String getRowId() {
    return this.rowId;
  }

  /**
   * The row id of the Row to be fetched, not to be used with location id.
   */
  public Selector setRowId(String rowId) {
    this.rowId = rowId;
    return this;
  }

  public void unsetRowId() {
    this.rowId = null;
  }

  /** Returns true if field rowId is set (has been assigned a value) and false otherwise */
  public boolean isSetRowId() {
    return this.rowId != null;
  }

  public void setRowIdIsSet(boolean value) {
    if (!value) {
      this.rowId = null;
    }
  }

  /**
   * The record id of the Record to be fetched, not to be used with location id.  However the row id needs to be provided to locate the correct Row with the requested Record.
   */
  public String getRecordId() {
    return this.recordId;
  }

  /**
   * The record id of the Record to be fetched, not to be used with location id.  However the row id needs to be provided to locate the correct Row with the requested Record.
   */
  public Selector setRecordId(String recordId) {
    this.recordId = recordId;
    return this;
  }

  public void unsetRecordId() {
    this.recordId = null;
  }

  /** Returns true if field recordId is set (has been assigned a value) and false otherwise */
  public boolean isSetRecordId() {
    return this.recordId != null;
  }

  public void setRecordIdIsSet(boolean value) {
    if (!value) {
      this.recordId = null;
    }
  }

  public int getColumnFamiliesToFetchSize() {
    return (this.columnFamiliesToFetch == null) ? 0 : this.columnFamiliesToFetch.size();
  }

  public java.util.Iterator<String> getColumnFamiliesToFetchIterator() {
    return (this.columnFamiliesToFetch == null) ? null : this.columnFamiliesToFetch.iterator();
  }

  public void addToColumnFamiliesToFetch(String elem) {
    if (this.columnFamiliesToFetch == null) {
      this.columnFamiliesToFetch = new HashSet<String>();
    }
    this.columnFamiliesToFetch.add(elem);
  }

  /**
   * The column families to fetch.  If null, fetch all.  If empty, fetch none.
   */
  public Set<String> getColumnFamiliesToFetch() {
    return this.columnFamiliesToFetch;
  }

  /**
   * The column families to fetch.  If null, fetch all.  If empty, fetch none.
   */
  public Selector setColumnFamiliesToFetch(Set<String> columnFamiliesToFetch) {
    this.columnFamiliesToFetch = columnFamiliesToFetch;
    return this;
  }

  public void unsetColumnFamiliesToFetch() {
    this.columnFamiliesToFetch = null;
  }

  /** Returns true if field columnFamiliesToFetch is set (has been assigned a value) and false otherwise */
  public boolean isSetColumnFamiliesToFetch() {
    return this.columnFamiliesToFetch != null;
  }

  public void setColumnFamiliesToFetchIsSet(boolean value) {
    if (!value) {
      this.columnFamiliesToFetch = null;
    }
  }

  public int getColumnsToFetchSize() {
    return (this.columnsToFetch == null) ? 0 : this.columnsToFetch.size();
  }

  public void putToColumnsToFetch(String key, Set<String> val) {
    if (this.columnsToFetch == null) {
      this.columnsToFetch = new HashMap<String,Set<String>>();
    }
    this.columnsToFetch.put(key, val);
  }

  /**
   * The columns in the families to fetch.  If null, fetch all.  If empty, fetch none.
   */
  public Map<String,Set<String>> getColumnsToFetch() {
    return this.columnsToFetch;
  }

  /**
   * The columns in the families to fetch.  If null, fetch all.  If empty, fetch none.
   */
  public Selector setColumnsToFetch(Map<String,Set<String>> columnsToFetch) {
    this.columnsToFetch = columnsToFetch;
    return this;
  }

  public void unsetColumnsToFetch() {
    this.columnsToFetch = null;
  }

  /** Returns true if field columnsToFetch is set (has been assigned a value) and false otherwise */
  public boolean isSetColumnsToFetch() {
    return this.columnsToFetch != null;
  }

  public void setColumnsToFetchIsSet(boolean value) {
    if (!value) {
      this.columnsToFetch = null;
    }
  }

  /**
   * @deprecated This value is no longer used.  This allows the fetch to see the most current data that has been added to the table.
   */
  public boolean isAllowStaleData() {
    return this.allowStaleData;
  }

  /**
   * @deprecated This value is no longer used.  This allows the fetch to see the most current data that has been added to the table.
   */
  public Selector setAllowStaleData(boolean allowStaleData) {
    this.allowStaleData = allowStaleData;
    setAllowStaleDataIsSet(true);
    return this;
  }

  public void unsetAllowStaleData() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __ALLOWSTALEDATA_ISSET_ID);
  }

  /** Returns true if field allowStaleData is set (has been assigned a value) and false otherwise */
  public boolean isSetAllowStaleData() {
    return EncodingUtils.testBit(__isset_bitfield, __ALLOWSTALEDATA_ISSET_ID);
  }

  public void setAllowStaleDataIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __ALLOWSTALEDATA_ISSET_ID, value);
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case RECORD_ONLY:
      if (value == null) {
        unsetRecordOnly();
      } else {
        setRecordOnly((Boolean)value);
      }
      break;

    case LOCATION_ID:
      if (value == null) {
        unsetLocationId();
      } else {
        setLocationId((String)value);
      }
      break;

    case ROW_ID:
      if (value == null) {
        unsetRowId();
      } else {
        setRowId((String)value);
      }
      break;

    case RECORD_ID:
      if (value == null) {
        unsetRecordId();
      } else {
        setRecordId((String)value);
      }
      break;

    case COLUMN_FAMILIES_TO_FETCH:
      if (value == null) {
        unsetColumnFamiliesToFetch();
      } else {
        setColumnFamiliesToFetch((Set<String>)value);
      }
      break;

    case COLUMNS_TO_FETCH:
      if (value == null) {
        unsetColumnsToFetch();
      } else {
        setColumnsToFetch((Map<String,Set<String>>)value);
      }
      break;

    case ALLOW_STALE_DATA:
      if (value == null) {
        unsetAllowStaleData();
      } else {
        setAllowStaleData((Boolean)value);
      }
      break;

    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case RECORD_ONLY:
      return Boolean.valueOf(isRecordOnly());

    case LOCATION_ID:
      return getLocationId();

    case ROW_ID:
      return getRowId();

    case RECORD_ID:
      return getRecordId();

    case COLUMN_FAMILIES_TO_FETCH:
      return getColumnFamiliesToFetch();

    case COLUMNS_TO_FETCH:
      return getColumnsToFetch();

    case ALLOW_STALE_DATA:
      return Boolean.valueOf(isAllowStaleData());

    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case RECORD_ONLY:
      return isSetRecordOnly();
    case LOCATION_ID:
      return isSetLocationId();
    case ROW_ID:
      return isSetRowId();
    case RECORD_ID:
      return isSetRecordId();
    case COLUMN_FAMILIES_TO_FETCH:
      return isSetColumnFamiliesToFetch();
    case COLUMNS_TO_FETCH:
      return isSetColumnsToFetch();
    case ALLOW_STALE_DATA:
      return isSetAllowStaleData();
    }
    throw new IllegalStateException();
  }

  @Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof Selector)
      return this.equals((Selector)that);
    return false;
  }

  public boolean equals(Selector that) {
    if (that == null)
      return false;

    boolean this_present_recordOnly = true;
    boolean that_present_recordOnly = true;
    if (this_present_recordOnly || that_present_recordOnly) {
      if (!(this_present_recordOnly && that_present_recordOnly))
        return false;
      if (this.recordOnly != that.recordOnly)
        return false;
    }

    boolean this_present_locationId = true && this.isSetLocationId();
    boolean that_present_locationId = true && that.isSetLocationId();
    if (this_present_locationId || that_present_locationId) {
      if (!(this_present_locationId && that_present_locationId))
        return false;
      if (!this.locationId.equals(that.locationId))
        return false;
    }

    boolean this_present_rowId = true && this.isSetRowId();
    boolean that_present_rowId = true && that.isSetRowId();
    if (this_present_rowId || that_present_rowId) {
      if (!(this_present_rowId && that_present_rowId))
        return false;
      if (!this.rowId.equals(that.rowId))
        return false;
    }

    boolean this_present_recordId = true && this.isSetRecordId();
    boolean that_present_recordId = true && that.isSetRecordId();
    if (this_present_recordId || that_present_recordId) {
      if (!(this_present_recordId && that_present_recordId))
        return false;
      if (!this.recordId.equals(that.recordId))
        return false;
    }

    boolean this_present_columnFamiliesToFetch = true && this.isSetColumnFamiliesToFetch();
    boolean that_present_columnFamiliesToFetch = true && that.isSetColumnFamiliesToFetch();
    if (this_present_columnFamiliesToFetch || that_present_columnFamiliesToFetch) {
      if (!(this_present_columnFamiliesToFetch && that_present_columnFamiliesToFetch))
        return false;
      if (!this.columnFamiliesToFetch.equals(that.columnFamiliesToFetch))
        return false;
    }

    boolean this_present_columnsToFetch = true && this.isSetColumnsToFetch();
    boolean that_present_columnsToFetch = true && that.isSetColumnsToFetch();
    if (this_present_columnsToFetch || that_present_columnsToFetch) {
      if (!(this_present_columnsToFetch && that_present_columnsToFetch))
        return false;
      if (!this.columnsToFetch.equals(that.columnsToFetch))
        return false;
    }

    boolean this_present_allowStaleData = true;
    boolean that_present_allowStaleData = true;
    if (this_present_allowStaleData || that_present_allowStaleData) {
      if (!(this_present_allowStaleData && that_present_allowStaleData))
        return false;
      if (this.allowStaleData != that.allowStaleData)
        return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    return 0;
  }

  public int compareTo(Selector other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;
    Selector typedOther = (Selector)other;

    lastComparison = Boolean.valueOf(isSetRecordOnly()).compareTo(typedOther.isSetRecordOnly());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRecordOnly()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.recordOnly, typedOther.recordOnly);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetLocationId()).compareTo(typedOther.isSetLocationId());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetLocationId()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.locationId, typedOther.locationId);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRowId()).compareTo(typedOther.isSetRowId());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRowId()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.rowId, typedOther.rowId);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetRecordId()).compareTo(typedOther.isSetRecordId());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetRecordId()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.recordId, typedOther.recordId);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetColumnFamiliesToFetch()).compareTo(typedOther.isSetColumnFamiliesToFetch());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetColumnFamiliesToFetch()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.columnFamiliesToFetch, typedOther.columnFamiliesToFetch);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetColumnsToFetch()).compareTo(typedOther.isSetColumnsToFetch());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetColumnsToFetch()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.columnsToFetch, typedOther.columnsToFetch);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetAllowStaleData()).compareTo(typedOther.isSetAllowStaleData());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetAllowStaleData()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.allowStaleData, typedOther.allowStaleData);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }

  public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
  }

  public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder("Selector(");
    boolean first = true;

    sb.append("recordOnly:");
    sb.append(this.recordOnly);
    first = false;
    if (!first) sb.append(", ");
    sb.append("locationId:");
    if (this.locationId == null) {
      sb.append("null");
    } else {
      sb.append(this.locationId);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("rowId:");
    if (this.rowId == null) {
      sb.append("null");
    } else {
      sb.append(this.rowId);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("recordId:");
    if (this.recordId == null) {
      sb.append("null");
    } else {
      sb.append(this.recordId);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("columnFamiliesToFetch:");
    if (this.columnFamiliesToFetch == null) {
      sb.append("null");
    } else {
      sb.append(this.columnFamiliesToFetch);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("columnsToFetch:");
    if (this.columnsToFetch == null) {
      sb.append("null");
    } else {
      sb.append(this.columnsToFetch);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("allowStaleData:");
    sb.append(this.allowStaleData);
    first = false;
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws org.apache.thrift.TException {
    // check for required fields
    // check for sub-struct validity
  }

  private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
    try {
      write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
    try {
      // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
      __isset_bitfield = 0;
      read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private static class SelectorStandardSchemeFactory implements SchemeFactory {
    public SelectorStandardScheme getScheme() {
      return new SelectorStandardScheme();
    }
  }

  private static class SelectorStandardScheme extends StandardScheme<Selector> {

    public void read(org.apache.thrift.protocol.TProtocol iprot, Selector struct) throws org.apache.thrift.TException {
      org.apache.thrift.protocol.TField schemeField;
      iprot.readStructBegin();
      while (true)
      {
        schemeField = iprot.readFieldBegin();
        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (schemeField.id) {
          case 1: // RECORD_ONLY
            if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
              struct.recordOnly = iprot.readBool();
              struct.setRecordOnlyIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 2: // LOCATION_ID
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.locationId = iprot.readString();
              struct.setLocationIdIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 3: // ROW_ID
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.rowId = iprot.readString();
              struct.setRowIdIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 4: // RECORD_ID
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.recordId = iprot.readString();
              struct.setRecordIdIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 5: // COLUMN_FAMILIES_TO_FETCH
            if (schemeField.type == org.apache.thrift.protocol.TType.SET) {
              {
                org.apache.thrift.protocol.TSet _set16 = iprot.readSetBegin();
                struct.columnFamiliesToFetch = new HashSet<String>(2*_set16.size);
                for (int _i17 = 0; _i17 < _set16.size; ++_i17)
                {
                  String _elem18; // required
                  _elem18 = iprot.readString();
                  struct.columnFamiliesToFetch.add(_elem18);
                }
                iprot.readSetEnd();
              }
              struct.setColumnFamiliesToFetchIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 6: // COLUMNS_TO_FETCH
            if (schemeField.type == org.apache.thrift.protocol.TType.MAP) {
              {
                org.apache.thrift.protocol.TMap _map19 = iprot.readMapBegin();
                struct.columnsToFetch = new HashMap<String,Set<String>>(2*_map19.size);
                for (int _i20 = 0; _i20 < _map19.size; ++_i20)
                {
                  String _key21; // required
                  Set<String> _val22; // optional
                  _key21 = iprot.readString();
                  {
                    org.apache.thrift.protocol.TSet _set23 = iprot.readSetBegin();
                    _val22 = new HashSet<String>(2*_set23.size);
                    for (int _i24 = 0; _i24 < _set23.size; ++_i24)
                    {
                      String _elem25; // required
                      _elem25 = iprot.readString();
                      _val22.add(_elem25);
                    }
                    iprot.readSetEnd();
                  }
                  struct.columnsToFetch.put(_key21, _val22);
                }
                iprot.readMapEnd();
              }
              struct.setColumnsToFetchIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 7: // ALLOW_STALE_DATA
            if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
              struct.allowStaleData = iprot.readBool();
              struct.setAllowStaleDataIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      struct.validate();
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot, Selector struct) throws org.apache.thrift.TException {
      struct.validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(RECORD_ONLY_FIELD_DESC);
      oprot.writeBool(struct.recordOnly);
      oprot.writeFieldEnd();
      if (struct.locationId != null) {
        oprot.writeFieldBegin(LOCATION_ID_FIELD_DESC);
        oprot.writeString(struct.locationId);
        oprot.writeFieldEnd();
      }
      if (struct.rowId != null) {
        oprot.writeFieldBegin(ROW_ID_FIELD_DESC);
        oprot.writeString(struct.rowId);
        oprot.writeFieldEnd();
      }
      if (struct.recordId != null) {
        oprot.writeFieldBegin(RECORD_ID_FIELD_DESC);
        oprot.writeString(struct.recordId);
        oprot.writeFieldEnd();
      }
      if (struct.columnFamiliesToFetch != null) {
        oprot.writeFieldBegin(COLUMN_FAMILIES_TO_FETCH_FIELD_DESC);
        {
          oprot.writeSetBegin(new org.apache.thrift.protocol.TSet(org.apache.thrift.protocol.TType.STRING, struct.columnFamiliesToFetch.size()));
          for (String _iter26 : struct.columnFamiliesToFetch)
          {
            oprot.writeString(_iter26);
          }
          oprot.writeSetEnd();
        }
        oprot.writeFieldEnd();
      }
      if (struct.columnsToFetch != null) {
        oprot.writeFieldBegin(COLUMNS_TO_FETCH_FIELD_DESC);
        {
          oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.SET, struct.columnsToFetch.size()));
          for (Map.Entry<String, Set<String>> _iter27 : struct.columnsToFetch.entrySet())
          {
            oprot.writeString(_iter27.getKey());
            {
              oprot.writeSetBegin(new org.apache.thrift.protocol.TSet(org.apache.thrift.protocol.TType.STRING, _iter27.getValue().size()));
              for (String _iter28 : _iter27.getValue())
              {
                oprot.writeString(_iter28);
              }
              oprot.writeSetEnd();
            }
          }
          oprot.writeMapEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(ALLOW_STALE_DATA_FIELD_DESC);
      oprot.writeBool(struct.allowStaleData);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

  }

  private static class SelectorTupleSchemeFactory implements SchemeFactory {
    public SelectorTupleScheme getScheme() {
      return new SelectorTupleScheme();
    }
  }

  private static class SelectorTupleScheme extends TupleScheme<Selector> {

    @Override
    public void write(org.apache.thrift.protocol.TProtocol prot, Selector struct) throws org.apache.thrift.TException {
      TTupleProtocol oprot = (TTupleProtocol) prot;
      BitSet optionals = new BitSet();
      if (struct.isSetRecordOnly()) {
        optionals.set(0);
      }
      if (struct.isSetLocationId()) {
        optionals.set(1);
      }
      if (struct.isSetRowId()) {
        optionals.set(2);
      }
      if (struct.isSetRecordId()) {
        optionals.set(3);
      }
      if (struct.isSetColumnFamiliesToFetch()) {
        optionals.set(4);
      }
      if (struct.isSetColumnsToFetch()) {
        optionals.set(5);
      }
      if (struct.isSetAllowStaleData()) {
        optionals.set(6);
      }
      oprot.writeBitSet(optionals, 7);
      if (struct.isSetRecordOnly()) {
        oprot.writeBool(struct.recordOnly);
      }
      if (struct.isSetLocationId()) {
        oprot.writeString(struct.locationId);
      }
      if (struct.isSetRowId()) {
        oprot.writeString(struct.rowId);
      }
      if (struct.isSetRecordId()) {
        oprot.writeString(struct.recordId);
      }
      if (struct.isSetColumnFamiliesToFetch()) {
        {
          oprot.writeI32(struct.columnFamiliesToFetch.size());
          for (String _iter29 : struct.columnFamiliesToFetch)
          {
            oprot.writeString(_iter29);
          }
        }
      }
      if (struct.isSetColumnsToFetch()) {
        {
          oprot.writeI32(struct.columnsToFetch.size());
          for (Map.Entry<String, Set<String>> _iter30 : struct.columnsToFetch.entrySet())
          {
            oprot.writeString(_iter30.getKey());
            {
              oprot.writeI32(_iter30.getValue().size());
              for (String _iter31 : _iter30.getValue())
              {
                oprot.writeString(_iter31);
              }
            }
          }
        }
      }
      if (struct.isSetAllowStaleData()) {
        oprot.writeBool(struct.allowStaleData);
      }
    }

    @Override
    public void read(org.apache.thrift.protocol.TProtocol prot, Selector struct) throws org.apache.thrift.TException {
      TTupleProtocol iprot = (TTupleProtocol) prot;
      BitSet incoming = iprot.readBitSet(7);
      if (incoming.get(0)) {
        struct.recordOnly = iprot.readBool();
        struct.setRecordOnlyIsSet(true);
      }
      if (incoming.get(1)) {
        struct.locationId = iprot.readString();
        struct.setLocationIdIsSet(true);
      }
      if (incoming.get(2)) {
        struct.rowId = iprot.readString();
        struct.setRowIdIsSet(true);
      }
      if (incoming.get(3)) {
        struct.recordId = iprot.readString();
        struct.setRecordIdIsSet(true);
      }
      if (incoming.get(4)) {
        {
          org.apache.thrift.protocol.TSet _set32 = new org.apache.thrift.protocol.TSet(org.apache.thrift.protocol.TType.STRING, iprot.readI32());
          struct.columnFamiliesToFetch = new HashSet<String>(2*_set32.size);
          for (int _i33 = 0; _i33 < _set32.size; ++_i33)
          {
            String _elem34; // required
            _elem34 = iprot.readString();
            struct.columnFamiliesToFetch.add(_elem34);
          }
        }
        struct.setColumnFamiliesToFetchIsSet(true);
      }
      if (incoming.get(5)) {
        {
          org.apache.thrift.protocol.TMap _map35 = new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.SET, iprot.readI32());
          struct.columnsToFetch = new HashMap<String,Set<String>>(2*_map35.size);
          for (int _i36 = 0; _i36 < _map35.size; ++_i36)
          {
            String _key37; // required
            Set<String> _val38; // optional
            _key37 = iprot.readString();
            {
              org.apache.thrift.protocol.TSet _set39 = new org.apache.thrift.protocol.TSet(org.apache.thrift.protocol.TType.STRING, iprot.readI32());
              _val38 = new HashSet<String>(2*_set39.size);
              for (int _i40 = 0; _i40 < _set39.size; ++_i40)
              {
                String _elem41; // required
                _elem41 = iprot.readString();
                _val38.add(_elem41);
              }
            }
            struct.columnsToFetch.put(_key37, _val38);
          }
        }
        struct.setColumnsToFetchIsSet(true);
      }
      if (incoming.get(6)) {
        struct.allowStaleData = iprot.readBool();
        struct.setAllowStaleDataIsSet(true);
      }
    }
  }

}

